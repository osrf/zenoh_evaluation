// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file datatypes.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "types/datatypes.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

Int32::Int32()
{
    // m_data com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2758fe70
    m_data = 0;

}

Int32::~Int32()
{
}

Int32::Int32(
        const Int32& x)
{
    m_data = x.m_data;
}

Int32::Int32(
        Int32&& x)
{
    m_data = x.m_data;
}

Int32& Int32::operator =(
        const Int32& x)
{

    m_data = x.m_data;

    return *this;
}

Int32& Int32::operator =(
        Int32&& x)
{

    m_data = x.m_data;

    return *this;
}

bool Int32::operator ==(
        const Int32& x)
{

    return (m_data == x.m_data);
}

bool Int32::operator !=(
        const Int32& x)
{
    return !(*this == x);
}

size_t Int32::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t Int32::getCdrSerializedSize(
        const Int32& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void Int32::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_data;

}

void Int32::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_data;
}

/*!
 * @brief This function sets a value in member data
 * @param _data New value for member data
 */
void Int32::data(
        int32_t _data)
{
    m_data = _data;
}

/*!
 * @brief This function returns the value of member data
 * @return Value of member data
 */
int32_t Int32::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
int32_t& Int32::data()
{
    return m_data;
}


size_t Int32::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool Int32::isKeyDefined()
{
    return false;
}

void Int32::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}

Int64::Int64()
{
    // m_data com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6ebc05a6
    m_data = 0;

}

Int64::~Int64()
{
}

Int64::Int64(
        const Int64& x)
{
    m_data = x.m_data;
}

Int64::Int64(
        Int64&& x)
{
    m_data = x.m_data;
}

Int64& Int64::operator =(
        const Int64& x)
{

    m_data = x.m_data;

    return *this;
}

Int64& Int64::operator =(
        Int64&& x)
{

    m_data = x.m_data;

    return *this;
}

bool Int64::operator ==(
        const Int64& x)
{

    return (m_data == x.m_data);
}

bool Int64::operator !=(
        const Int64& x)
{
    return !(*this == x);
}

size_t Int64::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t Int64::getCdrSerializedSize(
        const Int64& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void Int64::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_data;

}

void Int64::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_data;
}

/*!
 * @brief This function sets a value in member data
 * @param _data New value for member data
 */
void Int64::data(
        int64_t _data)
{
    m_data = _data;
}

/*!
 * @brief This function returns the value of member data
 * @return Value of member data
 */
int64_t Int64::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
int64_t& Int64::data()
{
    return m_data;
}


size_t Int64::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool Int64::isKeyDefined()
{
    return false;
}

void Int64::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}

Float32::Float32()
{
    // m_data com.eprosima.idl.parser.typecode.PrimitiveTypeCode@3cef309d
    m_data = 0.0;

}

Float32::~Float32()
{
}

Float32::Float32(
        const Float32& x)
{
    m_data = x.m_data;
}

Float32::Float32(
        Float32&& x)
{
    m_data = x.m_data;
}

Float32& Float32::operator =(
        const Float32& x)
{

    m_data = x.m_data;

    return *this;
}

Float32& Float32::operator =(
        Float32&& x)
{

    m_data = x.m_data;

    return *this;
}

bool Float32::operator ==(
        const Float32& x)
{

    return (m_data == x.m_data);
}

bool Float32::operator !=(
        const Float32& x)
{
    return !(*this == x);
}

size_t Float32::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t Float32::getCdrSerializedSize(
        const Float32& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void Float32::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_data;

}

void Float32::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_data;
}

/*!
 * @brief This function sets a value in member data
 * @param _data New value for member data
 */
void Float32::data(
        float _data)
{
    m_data = _data;
}

/*!
 * @brief This function returns the value of member data
 * @return Value of member data
 */
float Float32::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
float& Float32::data()
{
    return m_data;
}


size_t Float32::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool Float32::isKeyDefined()
{
    return false;
}

void Float32::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}

Float64::Float64()
{
    // m_data com.eprosima.idl.parser.typecode.PrimitiveTypeCode@3d99d22e
    m_data = 0.0;

}

Float64::~Float64()
{
}

Float64::Float64(
        const Float64& x)
{
    m_data = x.m_data;
}

Float64::Float64(
        Float64&& x)
{
    m_data = x.m_data;
}

Float64& Float64::operator =(
        const Float64& x)
{

    m_data = x.m_data;

    return *this;
}

Float64& Float64::operator =(
        Float64&& x)
{

    m_data = x.m_data;

    return *this;
}

bool Float64::operator ==(
        const Float64& x)
{

    return (m_data == x.m_data);
}

bool Float64::operator !=(
        const Float64& x)
{
    return !(*this == x);
}

size_t Float64::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t Float64::getCdrSerializedSize(
        const Float64& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void Float64::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_data;

}

void Float64::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_data;
}

/*!
 * @brief This function sets a value in member data
 * @param _data New value for member data
 */
void Float64::data(
        double _data)
{
    m_data = _data;
}

/*!
 * @brief This function returns the value of member data
 * @return Value of member data
 */
double Float64::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
double& Float64::data()
{
    return m_data;
}


size_t Float64::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool Float64::isKeyDefined()
{
    return false;
}

void Float64::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}

String::String()
{
    // m_data com.eprosima.idl.parser.typecode.StringTypeCode@57855c9a
    m_data ="";

}

String::~String()
{
}

String::String(
        const String& x)
{
    m_data = x.m_data;
}

String::String(
        String&& x)
{
    m_data = std::move(x.m_data);
}

String& String::operator =(
        const String& x)
{

    m_data = x.m_data;

    return *this;
}

String& String::operator =(
        String&& x)
{

    m_data = std::move(x.m_data);

    return *this;
}

bool String::operator ==(
        const String& x)
{

    return (m_data == x.m_data);
}

bool String::operator !=(
        const String& x)
{
    return !(*this == x);
}

size_t String::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 1024 + 1;

    return current_alignment - initial_alignment;
}

size_t String::getCdrSerializedSize(
        const String& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.data().size() + 1;

    return current_alignment - initial_alignment;
}

void String::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_data;

}

void String::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_data;
}

/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void String::data(
        const std::string& _data)
{
    m_data = _data;
}

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void String::data(
        std::string&& _data)
{
    m_data = std::move(_data);
}

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::string& String::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::string& String::data()
{
    return m_data;
}

size_t String::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool String::isKeyDefined()
{
    return false;
}

void String::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}

Timestamp::Timestamp()
{
    // m_sec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@68bbe345
    m_sec = 0;
    // m_nanosec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@30b8a058
    m_nanosec = 0;

}

Timestamp::~Timestamp()
{


}

Timestamp::Timestamp(
        const Timestamp& x)
{
    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
}

Timestamp::Timestamp(
        Timestamp&& x)
{
    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
}

Timestamp& Timestamp::operator =(
        const Timestamp& x)
{

    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;

    return *this;
}

Timestamp& Timestamp::operator =(
        Timestamp&& x)
{

    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;

    return *this;
}

bool Timestamp::operator ==(
        const Timestamp& x)
{

    return (m_sec == x.m_sec && m_nanosec == x.m_nanosec);
}

bool Timestamp::operator !=(
        const Timestamp& x)
{
    return !(*this == x);
}

size_t Timestamp::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t Timestamp::getCdrSerializedSize(
        const Timestamp& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void Timestamp::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_sec;
    scdr << m_nanosec;

}

void Timestamp::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_sec;
    dcdr >> m_nanosec;
}

/*!
 * @brief This function sets a value in member sec
 * @param _sec New value for member sec
 */
void Timestamp::sec(
        uint64_t _sec)
{
    m_sec = _sec;
}

/*!
 * @brief This function returns the value of member sec
 * @return Value of member sec
 */
uint64_t Timestamp::sec() const
{
    return m_sec;
}

/*!
 * @brief This function returns a reference to member sec
 * @return Reference to member sec
 */
uint64_t& Timestamp::sec()
{
    return m_sec;
}

/*!
 * @brief This function sets a value in member nanosec
 * @param _nanosec New value for member nanosec
 */
void Timestamp::nanosec(
        uint32_t _nanosec)
{
    m_nanosec = _nanosec;
}

/*!
 * @brief This function returns the value of member nanosec
 * @return Value of member nanosec
 */
uint32_t Timestamp::nanosec() const
{
    return m_nanosec;
}

/*!
 * @brief This function returns a reference to member nanosec
 * @return Reference to member nanosec
 */
uint32_t& Timestamp::nanosec()
{
    return m_nanosec;
}


size_t Timestamp::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool Timestamp::isKeyDefined()
{
    return false;
}

void Timestamp::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

Header::Header()
{
    // m_sec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4bbfb90a
    m_sec = 0;
    // m_nanosec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7c29daf3
    m_nanosec = 0;
    // m_frame_id com.eprosima.idl.parser.typecode.StringTypeCode@9660f4e
    m_frame_id ="";

}

Header::~Header()
{



}

Header::Header(
        const Header& x)
{
    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
    m_frame_id = x.m_frame_id;
}

Header::Header(
        Header&& x)
{
    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
    m_frame_id = std::move(x.m_frame_id);
}

Header& Header::operator =(
        const Header& x)
{

    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
    m_frame_id = x.m_frame_id;

    return *this;
}

Header& Header::operator =(
        Header&& x)
{

    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
    m_frame_id = std::move(x.m_frame_id);

    return *this;
}

bool Header::operator ==(
        const Header& x)
{

    return (m_sec == x.m_sec && m_nanosec == x.m_nanosec && m_frame_id == x.m_frame_id);
}

bool Header::operator !=(
        const Header& x)
{
    return !(*this == x);
}

size_t Header::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 256 + 1;


    return current_alignment - initial_alignment;
}

size_t Header::getCdrSerializedSize(
        const Header& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.frame_id().size() + 1;


    return current_alignment - initial_alignment;
}

void Header::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_sec;
    scdr << m_nanosec;
    scdr << m_frame_id;

}

void Header::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_sec;
    dcdr >> m_nanosec;
    dcdr >> m_frame_id;
}

/*!
 * @brief This function sets a value in member sec
 * @param _sec New value for member sec
 */
void Header::sec(
        int32_t _sec)
{
    m_sec = _sec;
}

/*!
 * @brief This function returns the value of member sec
 * @return Value of member sec
 */
int32_t Header::sec() const
{
    return m_sec;
}

/*!
 * @brief This function returns a reference to member sec
 * @return Reference to member sec
 */
int32_t& Header::sec()
{
    return m_sec;
}

/*!
 * @brief This function sets a value in member nanosec
 * @param _nanosec New value for member nanosec
 */
void Header::nanosec(
        uint32_t _nanosec)
{
    m_nanosec = _nanosec;
}

/*!
 * @brief This function returns the value of member nanosec
 * @return Value of member nanosec
 */
uint32_t Header::nanosec() const
{
    return m_nanosec;
}

/*!
 * @brief This function returns a reference to member nanosec
 * @return Reference to member nanosec
 */
uint32_t& Header::nanosec()
{
    return m_nanosec;
}

/*!
 * @brief This function copies the value in member frame_id
 * @param _frame_id New value to be copied in member frame_id
 */
void Header::frame_id(
        const std::string& _frame_id)
{
    m_frame_id = _frame_id;
}

/*!
 * @brief This function moves the value in member frame_id
 * @param _frame_id New value to be moved in member frame_id
 */
void Header::frame_id(
        std::string&& _frame_id)
{
    m_frame_id = std::move(_frame_id);
}

/*!
 * @brief This function returns a constant reference to member frame_id
 * @return Constant reference to member frame_id
 */
const std::string& Header::frame_id() const
{
    return m_frame_id;
}

/*!
 * @brief This function returns a reference to member frame_id
 * @return Reference to member frame_id
 */
std::string& Header::frame_id()
{
    return m_frame_id;
}

size_t Header::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool Header::isKeyDefined()
{
    return false;
}

void Header::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

Point::Point()
{
    // m_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@76707e36
    m_x = 0.0;
    // m_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@614ddd49
    m_y = 0.0;
    // m_z com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1f554b06
    m_z = 0.0;

}

Point::~Point()
{



}

Point::Point(
        const Point& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Point::Point(
        Point&& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Point& Point::operator =(
        const Point& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

Point& Point::operator =(
        Point&& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

bool Point::operator ==(
        const Point& x)
{

    return (m_x == x.m_x && m_y == x.m_y && m_z == x.m_z);
}

bool Point::operator !=(
        const Point& x)
{
    return !(*this == x);
}

size_t Point::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t Point::getCdrSerializedSize(
        const Point& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void Point::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x;
    scdr << m_y;
    scdr << m_z;

}

void Point::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x;
    dcdr >> m_y;
    dcdr >> m_z;
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void Point::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double Point::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& Point::x()
{
    return m_x;
}

/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void Point::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double Point::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& Point::y()
{
    return m_y;
}

/*!
 * @brief This function sets a value in member z
 * @param _z New value for member z
 */
void Point::z(
        double _z)
{
    m_z = _z;
}

/*!
 * @brief This function returns the value of member z
 * @return Value of member z
 */
double Point::z() const
{
    return m_z;
}

/*!
 * @brief This function returns a reference to member z
 * @return Reference to member z
 */
double& Point::z()
{
    return m_z;
}


size_t Point::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool Point::isKeyDefined()
{
    return false;
}

void Point::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

Quaternion::Quaternion()
{
    // m_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@131276c2
    m_x = 0.0;
    // m_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@26aa12dd
    m_y = 0.0;
    // m_z com.eprosima.idl.parser.typecode.PrimitiveTypeCode@711f39f9
    m_z = 0.0;
    // m_w com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7f13d6e
    m_w = 0.0;

}

Quaternion::~Quaternion()
{




}

Quaternion::Quaternion(
        const Quaternion& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;
}

Quaternion::Quaternion(
        Quaternion&& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;
}

Quaternion& Quaternion::operator =(
        const Quaternion& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;

    return *this;
}

Quaternion& Quaternion::operator =(
        Quaternion&& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;

    return *this;
}

bool Quaternion::operator ==(
        const Quaternion& x)
{

    return (m_x == x.m_x && m_y == x.m_y && m_z == x.m_z && m_w == x.m_w);
}

bool Quaternion::operator !=(
        const Quaternion& x)
{
    return !(*this == x);
}

size_t Quaternion::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t Quaternion::getCdrSerializedSize(
        const Quaternion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void Quaternion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x;
    scdr << m_y;
    scdr << m_z;
    scdr << m_w;

}

void Quaternion::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x;
    dcdr >> m_y;
    dcdr >> m_z;
    dcdr >> m_w;
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void Quaternion::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double Quaternion::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& Quaternion::x()
{
    return m_x;
}

/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void Quaternion::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double Quaternion::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& Quaternion::y()
{
    return m_y;
}

/*!
 * @brief This function sets a value in member z
 * @param _z New value for member z
 */
void Quaternion::z(
        double _z)
{
    m_z = _z;
}

/*!
 * @brief This function returns the value of member z
 * @return Value of member z
 */
double Quaternion::z() const
{
    return m_z;
}

/*!
 * @brief This function returns a reference to member z
 * @return Reference to member z
 */
double& Quaternion::z()
{
    return m_z;
}

/*!
 * @brief This function sets a value in member w
 * @param _w New value for member w
 */
void Quaternion::w(
        double _w)
{
    m_w = _w;
}

/*!
 * @brief This function returns the value of member w
 * @return Value of member w
 */
double Quaternion::w() const
{
    return m_w;
}

/*!
 * @brief This function returns a reference to member w
 * @return Reference to member w
 */
double& Quaternion::w()
{
    return m_w;
}


size_t Quaternion::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool Quaternion::isKeyDefined()
{
    return false;
}

void Quaternion::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        
}

Vector3::Vector3()
{
    // m_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@51cdd8a
    m_x = 0.0;
    // m_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@23faf8f2
    m_y = 0.0;
    // m_z com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2d6eabae
    m_z = 0.0;

}

Vector3::~Vector3()
{



}

Vector3::Vector3(
        const Vector3& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Vector3::Vector3(
        Vector3&& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Vector3& Vector3::operator =(
        const Vector3& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

Vector3& Vector3::operator =(
        Vector3&& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

bool Vector3::operator ==(
        const Vector3& x)
{

    return (m_x == x.m_x && m_y == x.m_y && m_z == x.m_z);
}

bool Vector3::operator !=(
        const Vector3& x)
{
    return !(*this == x);
}

size_t Vector3::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t Vector3::getCdrSerializedSize(
        const Vector3& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void Vector3::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x;
    scdr << m_y;
    scdr << m_z;

}

void Vector3::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x;
    dcdr >> m_y;
    dcdr >> m_z;
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void Vector3::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double Vector3::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& Vector3::x()
{
    return m_x;
}

/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void Vector3::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double Vector3::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& Vector3::y()
{
    return m_y;
}

/*!
 * @brief This function sets a value in member z
 * @param _z New value for member z
 */
void Vector3::z(
        double _z)
{
    m_z = _z;
}

/*!
 * @brief This function returns the value of member z
 * @return Value of member z
 */
double Vector3::z() const
{
    return m_z;
}

/*!
 * @brief This function returns a reference to member z
 * @return Reference to member z
 */
double& Vector3::z()
{
    return m_z;
}


size_t Vector3::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool Vector3::isKeyDefined()
{
    return false;
}

void Vector3::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

Vector3Stamped::Vector3Stamped()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@37374a5e

    // m_vector com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@4671e53b


}

Vector3Stamped::~Vector3Stamped()
{


}

Vector3Stamped::Vector3Stamped(
        const Vector3Stamped& x)
{
    m_header = x.m_header;
    m_vector = x.m_vector;
}

Vector3Stamped::Vector3Stamped(
        Vector3Stamped&& x)
{
    m_header = std::move(x.m_header);
    m_vector = std::move(x.m_vector);
}

Vector3Stamped& Vector3Stamped::operator =(
        const Vector3Stamped& x)
{

    m_header = x.m_header;
    m_vector = x.m_vector;

    return *this;
}

Vector3Stamped& Vector3Stamped::operator =(
        Vector3Stamped&& x)
{

    m_header = std::move(x.m_header);
    m_vector = std::move(x.m_vector);

    return *this;
}

bool Vector3Stamped::operator ==(
        const Vector3Stamped& x)
{

    return (m_header == x.m_header && m_vector == x.m_vector);
}

bool Vector3Stamped::operator !=(
        const Vector3Stamped& x)
{
    return !(*this == x);
}

size_t Vector3Stamped::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Vector3::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t Vector3Stamped::getCdrSerializedSize(
        const Vector3Stamped& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += Vector3::getCdrSerializedSize(data.vector(), current_alignment);

    return current_alignment - initial_alignment;
}

void Vector3Stamped::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_vector;

}

void Vector3Stamped::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_vector;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void Vector3Stamped::header(
        const Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void Vector3Stamped::header(
        Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const Header& Vector3Stamped::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
Header& Vector3Stamped::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member vector
 * @param _vector New value to be copied in member vector
 */
void Vector3Stamped::vector(
        const Vector3& _vector)
{
    m_vector = _vector;
}

/*!
 * @brief This function moves the value in member vector
 * @param _vector New value to be moved in member vector
 */
void Vector3Stamped::vector(
        Vector3&& _vector)
{
    m_vector = std::move(_vector);
}

/*!
 * @brief This function returns a constant reference to member vector
 * @return Constant reference to member vector
 */
const Vector3& Vector3Stamped::vector() const
{
    return m_vector;
}

/*!
 * @brief This function returns a reference to member vector
 * @return Reference to member vector
 */
Vector3& Vector3Stamped::vector()
{
    return m_vector;
}

size_t Vector3Stamped::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool Vector3Stamped::isKeyDefined()
{
    return false;
}

void Vector3Stamped::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

Pose::Pose()
{
    // m_position com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@6950e31

    // m_orientation com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@b7dd107


}

Pose::~Pose()
{


}

Pose::Pose(
        const Pose& x)
{
    m_position = x.m_position;
    m_orientation = x.m_orientation;
}

Pose::Pose(
        Pose&& x)
{
    m_position = std::move(x.m_position);
    m_orientation = std::move(x.m_orientation);
}

Pose& Pose::operator =(
        const Pose& x)
{

    m_position = x.m_position;
    m_orientation = x.m_orientation;

    return *this;
}

Pose& Pose::operator =(
        Pose&& x)
{

    m_position = std::move(x.m_position);
    m_orientation = std::move(x.m_orientation);

    return *this;
}

bool Pose::operator ==(
        const Pose& x)
{

    return (m_position == x.m_position && m_orientation == x.m_orientation);
}

bool Pose::operator !=(
        const Pose& x)
{
    return !(*this == x);
}

size_t Pose::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Point::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Quaternion::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t Pose::getCdrSerializedSize(
        const Pose& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Point::getCdrSerializedSize(data.position(), current_alignment);
    current_alignment += Quaternion::getCdrSerializedSize(data.orientation(), current_alignment);

    return current_alignment - initial_alignment;
}

void Pose::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_position;
    scdr << m_orientation;

}

void Pose::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_position;
    dcdr >> m_orientation;
}

/*!
 * @brief This function copies the value in member position
 * @param _position New value to be copied in member position
 */
void Pose::position(
        const Point& _position)
{
    m_position = _position;
}

/*!
 * @brief This function moves the value in member position
 * @param _position New value to be moved in member position
 */
void Pose::position(
        Point&& _position)
{
    m_position = std::move(_position);
}

/*!
 * @brief This function returns a constant reference to member position
 * @return Constant reference to member position
 */
const Point& Pose::position() const
{
    return m_position;
}

/*!
 * @brief This function returns a reference to member position
 * @return Reference to member position
 */
Point& Pose::position()
{
    return m_position;
}
/*!
 * @brief This function copies the value in member orientation
 * @param _orientation New value to be copied in member orientation
 */
void Pose::orientation(
        const Quaternion& _orientation)
{
    m_orientation = _orientation;
}

/*!
 * @brief This function moves the value in member orientation
 * @param _orientation New value to be moved in member orientation
 */
void Pose::orientation(
        Quaternion&& _orientation)
{
    m_orientation = std::move(_orientation);
}

/*!
 * @brief This function returns a constant reference to member orientation
 * @return Constant reference to member orientation
 */
const Quaternion& Pose::orientation() const
{
    return m_orientation;
}

/*!
 * @brief This function returns a reference to member orientation
 * @return Reference to member orientation
 */
Quaternion& Pose::orientation()
{
    return m_orientation;
}

size_t Pose::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool Pose::isKeyDefined()
{
    return false;
}

void Pose::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

Twist::Twist()
{
    // m_linear com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@4671e53b

    // m_angular com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@4671e53b


}

Twist::~Twist()
{


}

Twist::Twist(
        const Twist& x)
{
    m_linear = x.m_linear;
    m_angular = x.m_angular;
}

Twist::Twist(
        Twist&& x)
{
    m_linear = std::move(x.m_linear);
    m_angular = std::move(x.m_angular);
}

Twist& Twist::operator =(
        const Twist& x)
{

    m_linear = x.m_linear;
    m_angular = x.m_angular;

    return *this;
}

Twist& Twist::operator =(
        Twist&& x)
{

    m_linear = std::move(x.m_linear);
    m_angular = std::move(x.m_angular);

    return *this;
}

bool Twist::operator ==(
        const Twist& x)
{

    return (m_linear == x.m_linear && m_angular == x.m_angular);
}

bool Twist::operator !=(
        const Twist& x)
{
    return !(*this == x);
}

size_t Twist::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Vector3::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Vector3::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t Twist::getCdrSerializedSize(
        const Twist& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Vector3::getCdrSerializedSize(data.linear(), current_alignment);
    current_alignment += Vector3::getCdrSerializedSize(data.angular(), current_alignment);

    return current_alignment - initial_alignment;
}

void Twist::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_linear;
    scdr << m_angular;

}

void Twist::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_linear;
    dcdr >> m_angular;
}

/*!
 * @brief This function copies the value in member linear
 * @param _linear New value to be copied in member linear
 */
void Twist::linear(
        const Vector3& _linear)
{
    m_linear = _linear;
}

/*!
 * @brief This function moves the value in member linear
 * @param _linear New value to be moved in member linear
 */
void Twist::linear(
        Vector3&& _linear)
{
    m_linear = std::move(_linear);
}

/*!
 * @brief This function returns a constant reference to member linear
 * @return Constant reference to member linear
 */
const Vector3& Twist::linear() const
{
    return m_linear;
}

/*!
 * @brief This function returns a reference to member linear
 * @return Reference to member linear
 */
Vector3& Twist::linear()
{
    return m_linear;
}
/*!
 * @brief This function copies the value in member angular
 * @param _angular New value to be copied in member angular
 */
void Twist::angular(
        const Vector3& _angular)
{
    m_angular = _angular;
}

/*!
 * @brief This function moves the value in member angular
 * @param _angular New value to be moved in member angular
 */
void Twist::angular(
        Vector3&& _angular)
{
    m_angular = std::move(_angular);
}

/*!
 * @brief This function returns a constant reference to member angular
 * @return Constant reference to member angular
 */
const Vector3& Twist::angular() const
{
    return m_angular;
}

/*!
 * @brief This function returns a reference to member angular
 * @return Reference to member angular
 */
Vector3& Twist::angular()
{
    return m_angular;
}

size_t Twist::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool Twist::isKeyDefined()
{
    return false;
}

void Twist::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

TwistWithCovariance::TwistWithCovariance()
{
    // m_twist com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@706a04ae

    // m_covariance com.eprosima.idl.parser.typecode.SequenceTypeCode@6eceb130


}

TwistWithCovariance::~TwistWithCovariance()
{


}

TwistWithCovariance::TwistWithCovariance(
        const TwistWithCovariance& x)
{
    m_twist = x.m_twist;
    m_covariance = x.m_covariance;
}

TwistWithCovariance::TwistWithCovariance(
        TwistWithCovariance&& x)
{
    m_twist = std::move(x.m_twist);
    m_covariance = std::move(x.m_covariance);
}

TwistWithCovariance& TwistWithCovariance::operator =(
        const TwistWithCovariance& x)
{

    m_twist = x.m_twist;
    m_covariance = x.m_covariance;

    return *this;
}

TwistWithCovariance& TwistWithCovariance::operator =(
        TwistWithCovariance&& x)
{

    m_twist = std::move(x.m_twist);
    m_covariance = std::move(x.m_covariance);

    return *this;
}

bool TwistWithCovariance::operator ==(
        const TwistWithCovariance& x)
{

    return (m_twist == x.m_twist && m_covariance == x.m_covariance);
}

bool TwistWithCovariance::operator !=(
        const TwistWithCovariance& x)
{
    return !(*this == x);
}

size_t TwistWithCovariance::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Twist::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (256 * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);




    return current_alignment - initial_alignment;
}

size_t TwistWithCovariance::getCdrSerializedSize(
        const TwistWithCovariance& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Twist::getCdrSerializedSize(data.twist(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.covariance().size() > 0)
    {
        current_alignment += (data.covariance().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }




    return current_alignment - initial_alignment;
}

void TwistWithCovariance::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_twist;
    scdr << m_covariance;

}

void TwistWithCovariance::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_twist;
    dcdr >> m_covariance;
}

/*!
 * @brief This function copies the value in member twist
 * @param _twist New value to be copied in member twist
 */
void TwistWithCovariance::twist(
        const Twist& _twist)
{
    m_twist = _twist;
}

/*!
 * @brief This function moves the value in member twist
 * @param _twist New value to be moved in member twist
 */
void TwistWithCovariance::twist(
        Twist&& _twist)
{
    m_twist = std::move(_twist);
}

/*!
 * @brief This function returns a constant reference to member twist
 * @return Constant reference to member twist
 */
const Twist& TwistWithCovariance::twist() const
{
    return m_twist;
}

/*!
 * @brief This function returns a reference to member twist
 * @return Reference to member twist
 */
Twist& TwistWithCovariance::twist()
{
    return m_twist;
}
/*!
 * @brief This function copies the value in member covariance
 * @param _covariance New value to be copied in member covariance
 */
void TwistWithCovariance::covariance(
        const std::vector<double>& _covariance)
{
    m_covariance = _covariance;
}

/*!
 * @brief This function moves the value in member covariance
 * @param _covariance New value to be moved in member covariance
 */
void TwistWithCovariance::covariance(
        std::vector<double>&& _covariance)
{
    m_covariance = std::move(_covariance);
}

/*!
 * @brief This function returns a constant reference to member covariance
 * @return Constant reference to member covariance
 */
const std::vector<double>& TwistWithCovariance::covariance() const
{
    return m_covariance;
}

/*!
 * @brief This function returns a reference to member covariance
 * @return Reference to member covariance
 */
std::vector<double>& TwistWithCovariance::covariance()
{
    return m_covariance;
}

size_t TwistWithCovariance::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool TwistWithCovariance::isKeyDefined()
{
    return false;
}

void TwistWithCovariance::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

TwistWithCovarianceStamped::TwistWithCovarianceStamped()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@37374a5e

    // m_twist com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@954b04f


}

TwistWithCovarianceStamped::~TwistWithCovarianceStamped()
{


}

TwistWithCovarianceStamped::TwistWithCovarianceStamped(
        const TwistWithCovarianceStamped& x)
{
    m_header = x.m_header;
    m_twist = x.m_twist;
}

TwistWithCovarianceStamped::TwistWithCovarianceStamped(
        TwistWithCovarianceStamped&& x)
{
    m_header = std::move(x.m_header);
    m_twist = std::move(x.m_twist);
}

TwistWithCovarianceStamped& TwistWithCovarianceStamped::operator =(
        const TwistWithCovarianceStamped& x)
{

    m_header = x.m_header;
    m_twist = x.m_twist;

    return *this;
}

TwistWithCovarianceStamped& TwistWithCovarianceStamped::operator =(
        TwistWithCovarianceStamped&& x)
{

    m_header = std::move(x.m_header);
    m_twist = std::move(x.m_twist);

    return *this;
}

bool TwistWithCovarianceStamped::operator ==(
        const TwistWithCovarianceStamped& x)
{

    return (m_header == x.m_header && m_twist == x.m_twist);
}

bool TwistWithCovarianceStamped::operator !=(
        const TwistWithCovarianceStamped& x)
{
    return !(*this == x);
}

size_t TwistWithCovarianceStamped::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += TwistWithCovariance::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t TwistWithCovarianceStamped::getCdrSerializedSize(
        const TwistWithCovarianceStamped& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += TwistWithCovariance::getCdrSerializedSize(data.twist(), current_alignment);

    return current_alignment - initial_alignment;
}

void TwistWithCovarianceStamped::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_twist;

}

void TwistWithCovarianceStamped::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_twist;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void TwistWithCovarianceStamped::header(
        const Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void TwistWithCovarianceStamped::header(
        Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const Header& TwistWithCovarianceStamped::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
Header& TwistWithCovarianceStamped::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member twist
 * @param _twist New value to be copied in member twist
 */
void TwistWithCovarianceStamped::twist(
        const TwistWithCovariance& _twist)
{
    m_twist = _twist;
}

/*!
 * @brief This function moves the value in member twist
 * @param _twist New value to be moved in member twist
 */
void TwistWithCovarianceStamped::twist(
        TwistWithCovariance&& _twist)
{
    m_twist = std::move(_twist);
}

/*!
 * @brief This function returns a constant reference to member twist
 * @return Constant reference to member twist
 */
const TwistWithCovariance& TwistWithCovarianceStamped::twist() const
{
    return m_twist;
}

/*!
 * @brief This function returns a reference to member twist
 * @return Reference to member twist
 */
TwistWithCovariance& TwistWithCovarianceStamped::twist()
{
    return m_twist;
}

size_t TwistWithCovarianceStamped::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool TwistWithCovarianceStamped::isKeyDefined()
{
    return false;
}

void TwistWithCovarianceStamped::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

Wrench::Wrench()
{
    // m_force com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@4671e53b

    // m_torque com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@4671e53b


}

Wrench::~Wrench()
{


}

Wrench::Wrench(
        const Wrench& x)
{
    m_force = x.m_force;
    m_torque = x.m_torque;
}

Wrench::Wrench(
        Wrench&& x)
{
    m_force = std::move(x.m_force);
    m_torque = std::move(x.m_torque);
}

Wrench& Wrench::operator =(
        const Wrench& x)
{

    m_force = x.m_force;
    m_torque = x.m_torque;

    return *this;
}

Wrench& Wrench::operator =(
        Wrench&& x)
{

    m_force = std::move(x.m_force);
    m_torque = std::move(x.m_torque);

    return *this;
}

bool Wrench::operator ==(
        const Wrench& x)
{

    return (m_force == x.m_force && m_torque == x.m_torque);
}

bool Wrench::operator !=(
        const Wrench& x)
{
    return !(*this == x);
}

size_t Wrench::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Vector3::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Vector3::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t Wrench::getCdrSerializedSize(
        const Wrench& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Vector3::getCdrSerializedSize(data.force(), current_alignment);
    current_alignment += Vector3::getCdrSerializedSize(data.torque(), current_alignment);

    return current_alignment - initial_alignment;
}

void Wrench::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_force;
    scdr << m_torque;

}

void Wrench::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_force;
    dcdr >> m_torque;
}

/*!
 * @brief This function copies the value in member force
 * @param _force New value to be copied in member force
 */
void Wrench::force(
        const Vector3& _force)
{
    m_force = _force;
}

/*!
 * @brief This function moves the value in member force
 * @param _force New value to be moved in member force
 */
void Wrench::force(
        Vector3&& _force)
{
    m_force = std::move(_force);
}

/*!
 * @brief This function returns a constant reference to member force
 * @return Constant reference to member force
 */
const Vector3& Wrench::force() const
{
    return m_force;
}

/*!
 * @brief This function returns a reference to member force
 * @return Reference to member force
 */
Vector3& Wrench::force()
{
    return m_force;
}
/*!
 * @brief This function copies the value in member torque
 * @param _torque New value to be copied in member torque
 */
void Wrench::torque(
        const Vector3& _torque)
{
    m_torque = _torque;
}

/*!
 * @brief This function moves the value in member torque
 * @param _torque New value to be moved in member torque
 */
void Wrench::torque(
        Vector3&& _torque)
{
    m_torque = std::move(_torque);
}

/*!
 * @brief This function returns a constant reference to member torque
 * @return Constant reference to member torque
 */
const Vector3& Wrench::torque() const
{
    return m_torque;
}

/*!
 * @brief This function returns a reference to member torque
 * @return Reference to member torque
 */
Vector3& Wrench::torque()
{
    return m_torque;
}

size_t Wrench::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool Wrench::isKeyDefined()
{
    return false;
}

void Wrench::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

WrenchStamped::WrenchStamped()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@37374a5e

    // m_wrench com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@306279ee


}

WrenchStamped::~WrenchStamped()
{


}

WrenchStamped::WrenchStamped(
        const WrenchStamped& x)
{
    m_header = x.m_header;
    m_wrench = x.m_wrench;
}

WrenchStamped::WrenchStamped(
        WrenchStamped&& x)
{
    m_header = std::move(x.m_header);
    m_wrench = std::move(x.m_wrench);
}

WrenchStamped& WrenchStamped::operator =(
        const WrenchStamped& x)
{

    m_header = x.m_header;
    m_wrench = x.m_wrench;

    return *this;
}

WrenchStamped& WrenchStamped::operator =(
        WrenchStamped&& x)
{

    m_header = std::move(x.m_header);
    m_wrench = std::move(x.m_wrench);

    return *this;
}

bool WrenchStamped::operator ==(
        const WrenchStamped& x)
{

    return (m_header == x.m_header && m_wrench == x.m_wrench);
}

bool WrenchStamped::operator !=(
        const WrenchStamped& x)
{
    return !(*this == x);
}

size_t WrenchStamped::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Wrench::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t WrenchStamped::getCdrSerializedSize(
        const WrenchStamped& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += Wrench::getCdrSerializedSize(data.wrench(), current_alignment);

    return current_alignment - initial_alignment;
}

void WrenchStamped::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_wrench;

}

void WrenchStamped::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_wrench;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void WrenchStamped::header(
        const Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void WrenchStamped::header(
        Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const Header& WrenchStamped::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
Header& WrenchStamped::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member wrench
 * @param _wrench New value to be copied in member wrench
 */
void WrenchStamped::wrench(
        const Wrench& _wrench)
{
    m_wrench = _wrench;
}

/*!
 * @brief This function moves the value in member wrench
 * @param _wrench New value to be moved in member wrench
 */
void WrenchStamped::wrench(
        Wrench&& _wrench)
{
    m_wrench = std::move(_wrench);
}

/*!
 * @brief This function returns a constant reference to member wrench
 * @return Constant reference to member wrench
 */
const Wrench& WrenchStamped::wrench() const
{
    return m_wrench;
}

/*!
 * @brief This function returns a reference to member wrench
 * @return Reference to member wrench
 */
Wrench& WrenchStamped::wrench()
{
    return m_wrench;
}

size_t WrenchStamped::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool WrenchStamped::isKeyDefined()
{
    return false;
}

void WrenchStamped::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

Image::Image()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@37374a5e

    // m_height com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4cf4d528
    m_height = 0;
    // m_width com.eprosima.idl.parser.typecode.PrimitiveTypeCode@77846d2c
    m_width = 0;
    // m_encoding com.eprosima.idl.parser.typecode.StringTypeCode@548ad73b
    m_encoding ="";
    // m_is_bigendian com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4c762604
    m_is_bigendian = false;
    // m_step com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2641e737
    m_step = 0;
    // m_data com.eprosima.idl.parser.typecode.SequenceTypeCode@727803de


}

Image::~Image()
{







}

Image::Image(
        const Image& x)
{
    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = x.m_encoding;
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = x.m_data;
}

Image::Image(
        Image&& x)
{
    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = std::move(x.m_encoding);
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = std::move(x.m_data);
}

Image& Image::operator =(
        const Image& x)
{

    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = x.m_encoding;
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = x.m_data;

    return *this;
}

Image& Image::operator =(
        Image&& x)
{

    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = std::move(x.m_encoding);
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = std::move(x.m_data);

    return *this;
}

bool Image::operator ==(
        const Image& x)
{

    return (m_header == x.m_header && m_height == x.m_height && m_width == x.m_width && m_encoding == x.m_encoding && m_is_bigendian == x.m_is_bigendian && m_step == x.m_step && m_data == x.m_data);
}

bool Image::operator !=(
        const Image& x)
{
    return !(*this == x);
}

size_t Image::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 256 + 1;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (3840*2160*3 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t Image::getCdrSerializedSize(
        const Image& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.encoding().size() + 1;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.data().size() > 0)
    {
        current_alignment += (data.data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }




    return current_alignment - initial_alignment;
}

void Image::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_height;
    scdr << m_width;
    scdr << m_encoding;
    scdr << m_is_bigendian;
    scdr << m_step;
    scdr << m_data;

}

void Image::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_height;
    dcdr >> m_width;
    dcdr >> m_encoding;
    dcdr >> m_is_bigendian;
    dcdr >> m_step;
    dcdr >> m_data;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void Image::header(
        const Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void Image::header(
        Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const Header& Image::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
Header& Image::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void Image::height(
        uint32_t _height)
{
    m_height = _height;
}

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
uint32_t Image::height() const
{
    return m_height;
}

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
uint32_t& Image::height()
{
    return m_height;
}

/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void Image::width(
        uint32_t _width)
{
    m_width = _width;
}

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
uint32_t Image::width() const
{
    return m_width;
}

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
uint32_t& Image::width()
{
    return m_width;
}

/*!
 * @brief This function copies the value in member encoding
 * @param _encoding New value to be copied in member encoding
 */
void Image::encoding(
        const std::string& _encoding)
{
    m_encoding = _encoding;
}

/*!
 * @brief This function moves the value in member encoding
 * @param _encoding New value to be moved in member encoding
 */
void Image::encoding(
        std::string&& _encoding)
{
    m_encoding = std::move(_encoding);
}

/*!
 * @brief This function returns a constant reference to member encoding
 * @return Constant reference to member encoding
 */
const std::string& Image::encoding() const
{
    return m_encoding;
}

/*!
 * @brief This function returns a reference to member encoding
 * @return Reference to member encoding
 */
std::string& Image::encoding()
{
    return m_encoding;
}
/*!
 * @brief This function sets a value in member is_bigendian
 * @param _is_bigendian New value for member is_bigendian
 */
void Image::is_bigendian(
        bool _is_bigendian)
{
    m_is_bigendian = _is_bigendian;
}

/*!
 * @brief This function returns the value of member is_bigendian
 * @return Value of member is_bigendian
 */
bool Image::is_bigendian() const
{
    return m_is_bigendian;
}

/*!
 * @brief This function returns a reference to member is_bigendian
 * @return Reference to member is_bigendian
 */
bool& Image::is_bigendian()
{
    return m_is_bigendian;
}

/*!
 * @brief This function sets a value in member step
 * @param _step New value for member step
 */
void Image::step(
        uint32_t _step)
{
    m_step = _step;
}

/*!
 * @brief This function returns the value of member step
 * @return Value of member step
 */
uint32_t Image::step() const
{
    return m_step;
}

/*!
 * @brief This function returns a reference to member step
 * @return Reference to member step
 */
uint32_t& Image::step()
{
    return m_step;
}

/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void Image::data(
        const std::vector<uint8_t>& _data)
{
    m_data = _data;
}

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void Image::data(
        std::vector<uint8_t>&& _data)
{
    m_data = std::move(_data);
}

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::vector<uint8_t>& Image::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::vector<uint8_t>& Image::data()
{
    return m_data;
}

size_t Image::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;










    return current_align;
}

bool Image::isKeyDefined()
{
    return false;
}

void Image::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
           
}









PointField::PointField()
{
    // m_name com.eprosima.idl.parser.typecode.StringTypeCode@68ceda24
    m_name ="";
    // m_offset com.eprosima.idl.parser.typecode.PrimitiveTypeCode@281e3708
    m_offset = 0;
    // m_datatype com.eprosima.idl.parser.typecode.PrimitiveTypeCode@35a50a4c
    m_datatype = 0;
    // m_count com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1f021e6c
    m_count = 0;

}

PointField::~PointField()
{




}

PointField::PointField(
        const PointField& x)
{
    m_name = x.m_name;
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;
}

PointField::PointField(
        PointField&& x)
{
    m_name = std::move(x.m_name);
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;
}

PointField& PointField::operator =(
        const PointField& x)
{

    m_name = x.m_name;
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;

    return *this;
}

PointField& PointField::operator =(
        PointField&& x)
{

    m_name = std::move(x.m_name);
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;

    return *this;
}

bool PointField::operator ==(
        const PointField& x)
{

    return (m_name == x.m_name && m_offset == x.m_offset && m_datatype == x.m_datatype && m_count == x.m_count);
}

// Manual patch
bool PointField::operator ==(
        const PointField& x) const
{

    return (m_name == x.m_name && m_offset == x.m_offset && m_datatype == x.m_datatype && m_count == x.m_count);
}

bool PointField::operator !=(
        const PointField& x)
{
    return !(*this == x);
}

size_t PointField::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 256 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t PointField::getCdrSerializedSize(
        const PointField& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void PointField::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_name;
    scdr << m_offset;
    scdr << m_datatype;
    scdr << m_count;

}

void PointField::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_name;
    dcdr >> m_offset;
    dcdr >> m_datatype;
    dcdr >> m_count;
}

/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
void PointField::name(
        const std::string& _name)
{
    m_name = _name;
}

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
void PointField::name(
        std::string&& _name)
{
    m_name = std::move(_name);
}

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
const std::string& PointField::name() const
{
    return m_name;
}

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
std::string& PointField::name()
{
    return m_name;
}
/*!
 * @brief This function sets a value in member offset
 * @param _offset New value for member offset
 */
void PointField::offset(
        uint32_t _offset)
{
    m_offset = _offset;
}

/*!
 * @brief This function returns the value of member offset
 * @return Value of member offset
 */
uint32_t PointField::offset() const
{
    return m_offset;
}

/*!
 * @brief This function returns a reference to member offset
 * @return Reference to member offset
 */
uint32_t& PointField::offset()
{
    return m_offset;
}

/*!
 * @brief This function sets a value in member datatype
 * @param _datatype New value for member datatype
 */
void PointField::datatype(
        uint8_t _datatype)
{
    m_datatype = _datatype;
}

/*!
 * @brief This function returns the value of member datatype
 * @return Value of member datatype
 */
uint8_t PointField::datatype() const
{
    return m_datatype;
}

/*!
 * @brief This function returns a reference to member datatype
 * @return Reference to member datatype
 */
uint8_t& PointField::datatype()
{
    return m_datatype;
}

/*!
 * @brief This function sets a value in member count
 * @param _count New value for member count
 */
void PointField::count(
        uint32_t _count)
{
    m_count = _count;
}

/*!
 * @brief This function returns the value of member count
 * @return Value of member count
 */
uint32_t PointField::count() const
{
    return m_count;
}

/*!
 * @brief This function returns a reference to member count
 * @return Reference to member count
 */
uint32_t& PointField::count()
{
    return m_count;
}


size_t PointField::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool PointField::isKeyDefined()
{
    return false;
}

void PointField::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        
}

PointCloud2::PointCloud2()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@37374a5e

    // m_height com.eprosima.idl.parser.typecode.PrimitiveTypeCode@103f852
    m_height = 0;
    // m_width com.eprosima.idl.parser.typecode.PrimitiveTypeCode@587c290d
    m_width = 0;
    // m_fields com.eprosima.idl.parser.typecode.SequenceTypeCode@4516af24

    // m_is_bigendian com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4ae82894
    m_is_bigendian = false;
    // m_point_step com.eprosima.idl.parser.typecode.PrimitiveTypeCode@543788f3
    m_point_step = 0;
    // m_row_step com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6d3af739
    m_row_step = 0;
    // m_data com.eprosima.idl.parser.typecode.SequenceTypeCode@1da51a35

    // m_is_dense com.eprosima.idl.parser.typecode.PrimitiveTypeCode@16022d9d
    m_is_dense = false;

}

PointCloud2::~PointCloud2()
{









}

PointCloud2::PointCloud2(
        const PointCloud2& x)
{
    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = x.m_fields;
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = x.m_data;
    m_is_dense = x.m_is_dense;
}

PointCloud2::PointCloud2(
        PointCloud2&& x)
{
    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = std::move(x.m_fields);
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = std::move(x.m_data);
    m_is_dense = x.m_is_dense;
}

PointCloud2& PointCloud2::operator =(
        const PointCloud2& x)
{

    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = x.m_fields;
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = x.m_data;
    m_is_dense = x.m_is_dense;

    return *this;
}

PointCloud2& PointCloud2::operator =(
        PointCloud2&& x)
{

    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = std::move(x.m_fields);
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = std::move(x.m_data);
    m_is_dense = x.m_is_dense;

    return *this;
}

bool PointCloud2::operator ==(
        const PointCloud2& x)
{

    return (m_header == x.m_header && m_height == x.m_height && m_width == x.m_width && m_fields == x.m_fields && m_is_bigendian == x.m_is_bigendian && m_point_step == x.m_point_step && m_row_step == x.m_row_step && m_data == x.m_data && m_is_dense == x.m_is_dense);
}

bool PointCloud2::operator !=(
        const PointCloud2& x)
{
    return !(*this == x);
}

size_t PointCloud2::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 256; ++a)
    {
        current_alignment += PointField::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (4*4*4*1920*1080 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t PointCloud2::getCdrSerializedSize(
        const PointCloud2& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.fields().size(); ++a)
    {
        current_alignment += PointField::getCdrSerializedSize(data.fields().at(a), current_alignment);}

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.data().size() > 0)
    {
        current_alignment += (data.data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }



    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void PointCloud2::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_height;
    scdr << m_width;
    scdr << m_fields;
    scdr << m_is_bigendian;
    scdr << m_point_step;
    scdr << m_row_step;
    scdr << m_data;
    scdr << m_is_dense;

}

void PointCloud2::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_height;
    dcdr >> m_width;
    dcdr >> m_fields;
    dcdr >> m_is_bigendian;
    dcdr >> m_point_step;
    dcdr >> m_row_step;
    dcdr >> m_data;
    dcdr >> m_is_dense;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void PointCloud2::header(
        const Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void PointCloud2::header(
        Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const Header& PointCloud2::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
Header& PointCloud2::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void PointCloud2::height(
        uint32_t _height)
{
    m_height = _height;
}

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
uint32_t PointCloud2::height() const
{
    return m_height;
}

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
uint32_t& PointCloud2::height()
{
    return m_height;
}

/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void PointCloud2::width(
        uint32_t _width)
{
    m_width = _width;
}

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
uint32_t PointCloud2::width() const
{
    return m_width;
}

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
uint32_t& PointCloud2::width()
{
    return m_width;
}

/*!
 * @brief This function copies the value in member fields
 * @param _fields New value to be copied in member fields
 */
void PointCloud2::fields(
        const std::vector<PointField>& _fields)
{
    m_fields = _fields;
}

/*!
 * @brief This function moves the value in member fields
 * @param _fields New value to be moved in member fields
 */
void PointCloud2::fields(
        std::vector<PointField>&& _fields)
{
    m_fields = std::move(_fields);
}

/*!
 * @brief This function returns a constant reference to member fields
 * @return Constant reference to member fields
 */
const std::vector<PointField>& PointCloud2::fields() const
{
    return m_fields;
}

/*!
 * @brief This function returns a reference to member fields
 * @return Reference to member fields
 */
std::vector<PointField>& PointCloud2::fields()
{
    return m_fields;
}
/*!
 * @brief This function sets a value in member is_bigendian
 * @param _is_bigendian New value for member is_bigendian
 */
void PointCloud2::is_bigendian(
        bool _is_bigendian)
{
    m_is_bigendian = _is_bigendian;
}

/*!
 * @brief This function returns the value of member is_bigendian
 * @return Value of member is_bigendian
 */
bool PointCloud2::is_bigendian() const
{
    return m_is_bigendian;
}

/*!
 * @brief This function returns a reference to member is_bigendian
 * @return Reference to member is_bigendian
 */
bool& PointCloud2::is_bigendian()
{
    return m_is_bigendian;
}

/*!
 * @brief This function sets a value in member point_step
 * @param _point_step New value for member point_step
 */
void PointCloud2::point_step(
        uint32_t _point_step)
{
    m_point_step = _point_step;
}

/*!
 * @brief This function returns the value of member point_step
 * @return Value of member point_step
 */
uint32_t PointCloud2::point_step() const
{
    return m_point_step;
}

/*!
 * @brief This function returns a reference to member point_step
 * @return Reference to member point_step
 */
uint32_t& PointCloud2::point_step()
{
    return m_point_step;
}

/*!
 * @brief This function sets a value in member row_step
 * @param _row_step New value for member row_step
 */
void PointCloud2::row_step(
        uint32_t _row_step)
{
    m_row_step = _row_step;
}

/*!
 * @brief This function returns the value of member row_step
 * @return Value of member row_step
 */
uint32_t PointCloud2::row_step() const
{
    return m_row_step;
}

/*!
 * @brief This function returns a reference to member row_step
 * @return Reference to member row_step
 */
uint32_t& PointCloud2::row_step()
{
    return m_row_step;
}

/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void PointCloud2::data(
        const std::vector<uint8_t>& _data)
{
    m_data = _data;
}

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void PointCloud2::data(
        std::vector<uint8_t>&& _data)
{
    m_data = std::move(_data);
}

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::vector<uint8_t>& PointCloud2::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::vector<uint8_t>& PointCloud2::data()
{
    return m_data;
}
/*!
 * @brief This function sets a value in member is_dense
 * @param _is_dense New value for member is_dense
 */
void PointCloud2::is_dense(
        bool _is_dense)
{
    m_is_dense = _is_dense;
}

/*!
 * @brief This function returns the value of member is_dense
 * @return Value of member is_dense
 */
bool PointCloud2::is_dense() const
{
    return m_is_dense;
}

/*!
 * @brief This function returns a reference to member is_dense
 * @return Reference to member is_dense
 */
bool& PointCloud2::is_dense()
{
    return m_is_dense;
}


size_t PointCloud2::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;












    return current_align;
}

bool PointCloud2::isKeyDefined()
{
    return false;
}

void PointCloud2::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
             
}

LaserScan::LaserScan()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@37374a5e

    // m_angle_min com.eprosima.idl.parser.typecode.PrimitiveTypeCode@44a3ec6b
    m_angle_min = 0.0;
    // m_angle_max com.eprosima.idl.parser.typecode.PrimitiveTypeCode@71623278
    m_angle_max = 0.0;
    // m_angle_increment com.eprosima.idl.parser.typecode.PrimitiveTypeCode@768b970c
    m_angle_increment = 0.0;
    // m_time_increment com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5a4041cc
    m_time_increment = 0.0;
    // m_scan_time com.eprosima.idl.parser.typecode.PrimitiveTypeCode@15b3e5b
    m_scan_time = 0.0;
    // m_range_min com.eprosima.idl.parser.typecode.PrimitiveTypeCode@61ca2dfa
    m_range_min = 0.0;
    // m_range_max com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4b53f538
    m_range_max = 0.0;
    // m_ranges com.eprosima.idl.parser.typecode.SequenceTypeCode@134593bf

    // m_intensities com.eprosima.idl.parser.typecode.SequenceTypeCode@4bb4de6a


}

LaserScan::~LaserScan()
{










}

LaserScan::LaserScan(
        const LaserScan& x)
{
    m_header = x.m_header;
    m_angle_min = x.m_angle_min;
    m_angle_max = x.m_angle_max;
    m_angle_increment = x.m_angle_increment;
    m_time_increment = x.m_time_increment;
    m_scan_time = x.m_scan_time;
    m_range_min = x.m_range_min;
    m_range_max = x.m_range_max;
    m_ranges = x.m_ranges;
    m_intensities = x.m_intensities;
}

LaserScan::LaserScan(
        LaserScan&& x)
{
    m_header = std::move(x.m_header);
    m_angle_min = x.m_angle_min;
    m_angle_max = x.m_angle_max;
    m_angle_increment = x.m_angle_increment;
    m_time_increment = x.m_time_increment;
    m_scan_time = x.m_scan_time;
    m_range_min = x.m_range_min;
    m_range_max = x.m_range_max;
    m_ranges = std::move(x.m_ranges);
    m_intensities = std::move(x.m_intensities);
}

LaserScan& LaserScan::operator =(
        const LaserScan& x)
{

    m_header = x.m_header;
    m_angle_min = x.m_angle_min;
    m_angle_max = x.m_angle_max;
    m_angle_increment = x.m_angle_increment;
    m_time_increment = x.m_time_increment;
    m_scan_time = x.m_scan_time;
    m_range_min = x.m_range_min;
    m_range_max = x.m_range_max;
    m_ranges = x.m_ranges;
    m_intensities = x.m_intensities;

    return *this;
}

LaserScan& LaserScan::operator =(
        LaserScan&& x)
{

    m_header = std::move(x.m_header);
    m_angle_min = x.m_angle_min;
    m_angle_max = x.m_angle_max;
    m_angle_increment = x.m_angle_increment;
    m_time_increment = x.m_time_increment;
    m_scan_time = x.m_scan_time;
    m_range_min = x.m_range_min;
    m_range_max = x.m_range_max;
    m_ranges = std::move(x.m_ranges);
    m_intensities = std::move(x.m_intensities);

    return *this;
}

bool LaserScan::operator ==(
        const LaserScan& x)
{

    return (m_header == x.m_header && m_angle_min == x.m_angle_min && m_angle_max == x.m_angle_max && m_angle_increment == x.m_angle_increment && m_time_increment == x.m_time_increment && m_scan_time == x.m_scan_time && m_range_min == x.m_range_min && m_range_max == x.m_range_max && m_ranges == x.m_ranges && m_intensities == x.m_intensities);
}

bool LaserScan::operator !=(
        const LaserScan& x)
{
    return !(*this == x);
}

size_t LaserScan::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (1024 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (1024 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);




    return current_alignment - initial_alignment;
}

size_t LaserScan::getCdrSerializedSize(
        const LaserScan& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.ranges().size() > 0)
    {
        current_alignment += (data.ranges().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.intensities().size() > 0)
    {
        current_alignment += (data.intensities().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }




    return current_alignment - initial_alignment;
}

void LaserScan::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_angle_min;
    scdr << m_angle_max;
    scdr << m_angle_increment;
    scdr << m_time_increment;
    scdr << m_scan_time;
    scdr << m_range_min;
    scdr << m_range_max;
    scdr << m_ranges;
    scdr << m_intensities;

}

void LaserScan::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_angle_min;
    dcdr >> m_angle_max;
    dcdr >> m_angle_increment;
    dcdr >> m_time_increment;
    dcdr >> m_scan_time;
    dcdr >> m_range_min;
    dcdr >> m_range_max;
    dcdr >> m_ranges;
    dcdr >> m_intensities;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void LaserScan::header(
        const Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void LaserScan::header(
        Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const Header& LaserScan::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
Header& LaserScan::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member angle_min
 * @param _angle_min New value for member angle_min
 */
void LaserScan::angle_min(
        float _angle_min)
{
    m_angle_min = _angle_min;
}

/*!
 * @brief This function returns the value of member angle_min
 * @return Value of member angle_min
 */
float LaserScan::angle_min() const
{
    return m_angle_min;
}

/*!
 * @brief This function returns a reference to member angle_min
 * @return Reference to member angle_min
 */
float& LaserScan::angle_min()
{
    return m_angle_min;
}

/*!
 * @brief This function sets a value in member angle_max
 * @param _angle_max New value for member angle_max
 */
void LaserScan::angle_max(
        float _angle_max)
{
    m_angle_max = _angle_max;
}

/*!
 * @brief This function returns the value of member angle_max
 * @return Value of member angle_max
 */
float LaserScan::angle_max() const
{
    return m_angle_max;
}

/*!
 * @brief This function returns a reference to member angle_max
 * @return Reference to member angle_max
 */
float& LaserScan::angle_max()
{
    return m_angle_max;
}

/*!
 * @brief This function sets a value in member angle_increment
 * @param _angle_increment New value for member angle_increment
 */
void LaserScan::angle_increment(
        float _angle_increment)
{
    m_angle_increment = _angle_increment;
}

/*!
 * @brief This function returns the value of member angle_increment
 * @return Value of member angle_increment
 */
float LaserScan::angle_increment() const
{
    return m_angle_increment;
}

/*!
 * @brief This function returns a reference to member angle_increment
 * @return Reference to member angle_increment
 */
float& LaserScan::angle_increment()
{
    return m_angle_increment;
}

/*!
 * @brief This function sets a value in member time_increment
 * @param _time_increment New value for member time_increment
 */
void LaserScan::time_increment(
        float _time_increment)
{
    m_time_increment = _time_increment;
}

/*!
 * @brief This function returns the value of member time_increment
 * @return Value of member time_increment
 */
float LaserScan::time_increment() const
{
    return m_time_increment;
}

/*!
 * @brief This function returns a reference to member time_increment
 * @return Reference to member time_increment
 */
float& LaserScan::time_increment()
{
    return m_time_increment;
}

/*!
 * @brief This function sets a value in member scan_time
 * @param _scan_time New value for member scan_time
 */
void LaserScan::scan_time(
        float _scan_time)
{
    m_scan_time = _scan_time;
}

/*!
 * @brief This function returns the value of member scan_time
 * @return Value of member scan_time
 */
float LaserScan::scan_time() const
{
    return m_scan_time;
}

/*!
 * @brief This function returns a reference to member scan_time
 * @return Reference to member scan_time
 */
float& LaserScan::scan_time()
{
    return m_scan_time;
}

/*!
 * @brief This function sets a value in member range_min
 * @param _range_min New value for member range_min
 */
void LaserScan::range_min(
        float _range_min)
{
    m_range_min = _range_min;
}

/*!
 * @brief This function returns the value of member range_min
 * @return Value of member range_min
 */
float LaserScan::range_min() const
{
    return m_range_min;
}

/*!
 * @brief This function returns a reference to member range_min
 * @return Reference to member range_min
 */
float& LaserScan::range_min()
{
    return m_range_min;
}

/*!
 * @brief This function sets a value in member range_max
 * @param _range_max New value for member range_max
 */
void LaserScan::range_max(
        float _range_max)
{
    m_range_max = _range_max;
}

/*!
 * @brief This function returns the value of member range_max
 * @return Value of member range_max
 */
float LaserScan::range_max() const
{
    return m_range_max;
}

/*!
 * @brief This function returns a reference to member range_max
 * @return Reference to member range_max
 */
float& LaserScan::range_max()
{
    return m_range_max;
}

/*!
 * @brief This function copies the value in member ranges
 * @param _ranges New value to be copied in member ranges
 */
void LaserScan::ranges(
        const std::vector<float>& _ranges)
{
    m_ranges = _ranges;
}

/*!
 * @brief This function moves the value in member ranges
 * @param _ranges New value to be moved in member ranges
 */
void LaserScan::ranges(
        std::vector<float>&& _ranges)
{
    m_ranges = std::move(_ranges);
}

/*!
 * @brief This function returns a constant reference to member ranges
 * @return Constant reference to member ranges
 */
const std::vector<float>& LaserScan::ranges() const
{
    return m_ranges;
}

/*!
 * @brief This function returns a reference to member ranges
 * @return Reference to member ranges
 */
std::vector<float>& LaserScan::ranges()
{
    return m_ranges;
}
/*!
 * @brief This function copies the value in member intensities
 * @param _intensities New value to be copied in member intensities
 */
void LaserScan::intensities(
        const std::vector<float>& _intensities)
{
    m_intensities = _intensities;
}

/*!
 * @brief This function moves the value in member intensities
 * @param _intensities New value to be moved in member intensities
 */
void LaserScan::intensities(
        std::vector<float>&& _intensities)
{
    m_intensities = std::move(_intensities);
}

/*!
 * @brief This function returns a constant reference to member intensities
 * @return Constant reference to member intensities
 */
const std::vector<float>& LaserScan::intensities() const
{
    return m_intensities;
}

/*!
 * @brief This function returns a reference to member intensities
 * @return Reference to member intensities
 */
std::vector<float>& LaserScan::intensities()
{
    return m_intensities;
}

size_t LaserScan::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;













    return current_align;
}

bool LaserScan::isKeyDefined()
{
    return false;
}

void LaserScan::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
              
}

BasicTypes::BasicTypes()
{
    // m_bool_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7ba18f1b
    m_bool_value = false;
    // m_int32_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2f8f5f62
    m_int32_value = 0;
    // m_uint32_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1068e947
    m_uint32_value = 0;
    // m_int64_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7dc222ae
    m_int64_value = 0;
    // m_uint64_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@aecb35a
    m_uint64_value = 0;
    // m_float_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5fcd892a
    m_float_value = 0.0;
    // m_double_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@8b87145
    m_double_value = 0.0;
    // m_string_value com.eprosima.idl.parser.typecode.StringTypeCode@6483f5ae
    m_string_value ="";

}

BasicTypes::~BasicTypes()
{








}

BasicTypes::BasicTypes(
        const BasicTypes& x)
{
    m_bool_value = x.m_bool_value;
    m_int32_value = x.m_int32_value;
    m_uint32_value = x.m_uint32_value;
    m_int64_value = x.m_int64_value;
    m_uint64_value = x.m_uint64_value;
    m_float_value = x.m_float_value;
    m_double_value = x.m_double_value;
    m_string_value = x.m_string_value;
}

BasicTypes::BasicTypes(
        BasicTypes&& x)
{
    m_bool_value = x.m_bool_value;
    m_int32_value = x.m_int32_value;
    m_uint32_value = x.m_uint32_value;
    m_int64_value = x.m_int64_value;
    m_uint64_value = x.m_uint64_value;
    m_float_value = x.m_float_value;
    m_double_value = x.m_double_value;
    m_string_value = std::move(x.m_string_value);
}

BasicTypes& BasicTypes::operator =(
        const BasicTypes& x)
{

    m_bool_value = x.m_bool_value;
    m_int32_value = x.m_int32_value;
    m_uint32_value = x.m_uint32_value;
    m_int64_value = x.m_int64_value;
    m_uint64_value = x.m_uint64_value;
    m_float_value = x.m_float_value;
    m_double_value = x.m_double_value;
    m_string_value = x.m_string_value;

    return *this;
}

BasicTypes& BasicTypes::operator =(
        BasicTypes&& x)
{

    m_bool_value = x.m_bool_value;
    m_int32_value = x.m_int32_value;
    m_uint32_value = x.m_uint32_value;
    m_int64_value = x.m_int64_value;
    m_uint64_value = x.m_uint64_value;
    m_float_value = x.m_float_value;
    m_double_value = x.m_double_value;
    m_string_value = std::move(x.m_string_value);

    return *this;
}

bool BasicTypes::operator ==(
        const BasicTypes& x)
{

    return (m_bool_value == x.m_bool_value && m_int32_value == x.m_int32_value && m_uint32_value == x.m_uint32_value && m_int64_value == x.m_int64_value && m_uint64_value == x.m_uint64_value && m_float_value == x.m_float_value && m_double_value == x.m_double_value && m_string_value == x.m_string_value);
}

bool BasicTypes::operator ==(
        const BasicTypes& x) const
{

    return (m_bool_value == x.m_bool_value && m_int32_value == x.m_int32_value && m_uint32_value == x.m_uint32_value && m_int64_value == x.m_int64_value && m_uint64_value == x.m_uint64_value && m_float_value == x.m_float_value && m_double_value == x.m_double_value && m_string_value == x.m_string_value);
}

bool BasicTypes::operator !=(
        const BasicTypes& x)
{
    return !(*this == x);
}

size_t BasicTypes::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 128 + 1;


    return current_alignment - initial_alignment;
}

size_t BasicTypes::getCdrSerializedSize(
        const BasicTypes& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.string_value().size() + 1;


    return current_alignment - initial_alignment;
}

void BasicTypes::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_bool_value;
    scdr << m_int32_value;
    scdr << m_uint32_value;
    scdr << m_int64_value;
    scdr << m_uint64_value;
    scdr << m_float_value;
    scdr << m_double_value;
    scdr << m_string_value;

}

void BasicTypes::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_bool_value;
    dcdr >> m_int32_value;
    dcdr >> m_uint32_value;
    dcdr >> m_int64_value;
    dcdr >> m_uint64_value;
    dcdr >> m_float_value;
    dcdr >> m_double_value;
    dcdr >> m_string_value;
}

/*!
 * @brief This function sets a value in member bool_value
 * @param _bool_value New value for member bool_value
 */
void BasicTypes::bool_value(
        bool _bool_value)
{
    m_bool_value = _bool_value;
}

/*!
 * @brief This function returns the value of member bool_value
 * @return Value of member bool_value
 */
bool BasicTypes::bool_value() const
{
    return m_bool_value;
}

/*!
 * @brief This function returns a reference to member bool_value
 * @return Reference to member bool_value
 */
bool& BasicTypes::bool_value()
{
    return m_bool_value;
}

/*!
 * @brief This function sets a value in member int32_value
 * @param _int32_value New value for member int32_value
 */
void BasicTypes::int32_value(
        int32_t _int32_value)
{
    m_int32_value = _int32_value;
}

/*!
 * @brief This function returns the value of member int32_value
 * @return Value of member int32_value
 */
int32_t BasicTypes::int32_value() const
{
    return m_int32_value;
}

/*!
 * @brief This function returns a reference to member int32_value
 * @return Reference to member int32_value
 */
int32_t& BasicTypes::int32_value()
{
    return m_int32_value;
}

/*!
 * @brief This function sets a value in member uint32_value
 * @param _uint32_value New value for member uint32_value
 */
void BasicTypes::uint32_value(
        uint32_t _uint32_value)
{
    m_uint32_value = _uint32_value;
}

/*!
 * @brief This function returns the value of member uint32_value
 * @return Value of member uint32_value
 */
uint32_t BasicTypes::uint32_value() const
{
    return m_uint32_value;
}

/*!
 * @brief This function returns a reference to member uint32_value
 * @return Reference to member uint32_value
 */
uint32_t& BasicTypes::uint32_value()
{
    return m_uint32_value;
}

/*!
 * @brief This function sets a value in member int64_value
 * @param _int64_value New value for member int64_value
 */
void BasicTypes::int64_value(
        int64_t _int64_value)
{
    m_int64_value = _int64_value;
}

/*!
 * @brief This function returns the value of member int64_value
 * @return Value of member int64_value
 */
int64_t BasicTypes::int64_value() const
{
    return m_int64_value;
}

/*!
 * @brief This function returns a reference to member int64_value
 * @return Reference to member int64_value
 */
int64_t& BasicTypes::int64_value()
{
    return m_int64_value;
}

/*!
 * @brief This function sets a value in member uint64_value
 * @param _uint64_value New value for member uint64_value
 */
void BasicTypes::uint64_value(
        uint64_t _uint64_value)
{
    m_uint64_value = _uint64_value;
}

/*!
 * @brief This function returns the value of member uint64_value
 * @return Value of member uint64_value
 */
uint64_t BasicTypes::uint64_value() const
{
    return m_uint64_value;
}

/*!
 * @brief This function returns a reference to member uint64_value
 * @return Reference to member uint64_value
 */
uint64_t& BasicTypes::uint64_value()
{
    return m_uint64_value;
}

/*!
 * @brief This function sets a value in member float_value
 * @param _float_value New value for member float_value
 */
void BasicTypes::float_value(
        float _float_value)
{
    m_float_value = _float_value;
}

/*!
 * @brief This function returns the value of member float_value
 * @return Value of member float_value
 */
float BasicTypes::float_value() const
{
    return m_float_value;
}

/*!
 * @brief This function returns a reference to member float_value
 * @return Reference to member float_value
 */
float& BasicTypes::float_value()
{
    return m_float_value;
}

/*!
 * @brief This function sets a value in member double_value
 * @param _double_value New value for member double_value
 */
void BasicTypes::double_value(
        double _double_value)
{
    m_double_value = _double_value;
}

/*!
 * @brief This function returns the value of member double_value
 * @return Value of member double_value
 */
double BasicTypes::double_value() const
{
    return m_double_value;
}

/*!
 * @brief This function returns a reference to member double_value
 * @return Reference to member double_value
 */
double& BasicTypes::double_value()
{
    return m_double_value;
}

/*!
 * @brief This function copies the value in member string_value
 * @param _string_value New value to be copied in member string_value
 */
void BasicTypes::string_value(
        const std::string& _string_value)
{
    m_string_value = _string_value;
}

/*!
 * @brief This function moves the value in member string_value
 * @param _string_value New value to be moved in member string_value
 */
void BasicTypes::string_value(
        std::string&& _string_value)
{
    m_string_value = std::move(_string_value);
}

/*!
 * @brief This function returns a constant reference to member string_value
 * @return Constant reference to member string_value
 */
const std::string& BasicTypes::string_value() const
{
    return m_string_value;
}

/*!
 * @brief This function returns a reference to member string_value
 * @return Reference to member string_value
 */
std::string& BasicTypes::string_value()
{
    return m_string_value;
}

size_t BasicTypes::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;











    return current_align;
}

bool BasicTypes::isKeyDefined()
{
    return false;
}

void BasicTypes::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
            
}

BigData::BigData()
{
    // m_timestamp com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@b9afc07

    // m_bool_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@382db087
    m_bool_value = false;
    // m_int32_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@73d4cc9e
    m_int32_value = 0;
    // m_uint32_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@80169cf
    m_uint32_value = 0;
    // m_int64_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5427c60c
    m_int64_value = 0;
    // m_uint64_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@15bfd87
    m_uint64_value = 0;
    // m_float_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@543e710e
    m_float_value = 0.0;
    // m_double_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@57f23557
    m_double_value = 0.0;
    // m_string_value com.eprosima.idl.parser.typecode.StringTypeCode@3d0f8e03
    m_string_value ="";
    // m_basic_types_values com.eprosima.idl.parser.typecode.SequenceTypeCode@6366ebe0

    // m_image_value com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@44f75083

    // m_point_cloud_value com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@2698dc7


}

BigData::~BigData()
{












}

BigData::BigData(
        const BigData& x)
{
    m_timestamp = x.m_timestamp;
    m_bool_value = x.m_bool_value;
    m_int32_value = x.m_int32_value;
    m_uint32_value = x.m_uint32_value;
    m_int64_value = x.m_int64_value;
    m_uint64_value = x.m_uint64_value;
    m_float_value = x.m_float_value;
    m_double_value = x.m_double_value;
    m_string_value = x.m_string_value;
    m_basic_types_values = x.m_basic_types_values;
    m_image_value = x.m_image_value;
    m_point_cloud_value = x.m_point_cloud_value;
}

BigData::BigData(
        BigData&& x)
{
    m_timestamp = std::move(x.m_timestamp);
    m_bool_value = x.m_bool_value;
    m_int32_value = x.m_int32_value;
    m_uint32_value = x.m_uint32_value;
    m_int64_value = x.m_int64_value;
    m_uint64_value = x.m_uint64_value;
    m_float_value = x.m_float_value;
    m_double_value = x.m_double_value;
    m_string_value = std::move(x.m_string_value);
    m_basic_types_values = std::move(x.m_basic_types_values);
    m_image_value = std::move(x.m_image_value);
    m_point_cloud_value = std::move(x.m_point_cloud_value);
}

BigData& BigData::operator =(
        const BigData& x)
{

    m_timestamp = x.m_timestamp;
    m_bool_value = x.m_bool_value;
    m_int32_value = x.m_int32_value;
    m_uint32_value = x.m_uint32_value;
    m_int64_value = x.m_int64_value;
    m_uint64_value = x.m_uint64_value;
    m_float_value = x.m_float_value;
    m_double_value = x.m_double_value;
    m_string_value = x.m_string_value;
    m_basic_types_values = x.m_basic_types_values;
    m_image_value = x.m_image_value;
    m_point_cloud_value = x.m_point_cloud_value;

    return *this;
}

BigData& BigData::operator =(
        BigData&& x)
{

    m_timestamp = std::move(x.m_timestamp);
    m_bool_value = x.m_bool_value;
    m_int32_value = x.m_int32_value;
    m_uint32_value = x.m_uint32_value;
    m_int64_value = x.m_int64_value;
    m_uint64_value = x.m_uint64_value;
    m_float_value = x.m_float_value;
    m_double_value = x.m_double_value;
    m_string_value = std::move(x.m_string_value);
    m_basic_types_values = std::move(x.m_basic_types_values);
    m_image_value = std::move(x.m_image_value);
    m_point_cloud_value = std::move(x.m_point_cloud_value);

    return *this;
}

bool BigData::operator ==(
        const BigData& x)
{

    return (m_timestamp == x.m_timestamp && m_bool_value == x.m_bool_value && m_int32_value == x.m_int32_value && m_uint32_value == x.m_uint32_value && m_int64_value == x.m_int64_value && m_uint64_value == x.m_uint64_value && m_float_value == x.m_float_value && m_double_value == x.m_double_value && m_string_value == x.m_string_value && m_basic_types_values == x.m_basic_types_values && m_image_value == x.m_image_value && m_point_cloud_value == x.m_point_cloud_value);
}

bool BigData::operator !=(
        const BigData& x)
{
    return !(*this == x);
}

size_t BigData::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Timestamp::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 256 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 3; ++a)
    {
        current_alignment += BasicTypes::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += Image::getMaxCdrSerializedSize(current_alignment);
    current_alignment += PointCloud2::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t BigData::getCdrSerializedSize(
        const BigData& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Timestamp::getCdrSerializedSize(data.timestamp(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.string_value().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.basic_types_values().size(); ++a)
    {
        current_alignment += BasicTypes::getCdrSerializedSize(data.basic_types_values().at(a), current_alignment);}

    current_alignment += Image::getCdrSerializedSize(data.image_value(), current_alignment);
    current_alignment += PointCloud2::getCdrSerializedSize(data.point_cloud_value(), current_alignment);

    return current_alignment - initial_alignment;
}

void BigData::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_timestamp;
    scdr << m_bool_value;
    scdr << m_int32_value;
    scdr << m_uint32_value;
    scdr << m_int64_value;
    scdr << m_uint64_value;
    scdr << m_float_value;
    scdr << m_double_value;
    scdr << m_string_value;
    scdr << m_basic_types_values;
    scdr << m_image_value;
    scdr << m_point_cloud_value;

}

void BigData::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_timestamp;
    dcdr >> m_bool_value;
    dcdr >> m_int32_value;
    dcdr >> m_uint32_value;
    dcdr >> m_int64_value;
    dcdr >> m_uint64_value;
    dcdr >> m_float_value;
    dcdr >> m_double_value;
    dcdr >> m_string_value;
    dcdr >> m_basic_types_values;
    dcdr >> m_image_value;
    dcdr >> m_point_cloud_value;
}

/*!
 * @brief This function copies the value in member timestamp
 * @param _timestamp New value to be copied in member timestamp
 */
void BigData::timestamp(
        const Timestamp& _timestamp)
{
    m_timestamp = _timestamp;
}

/*!
 * @brief This function moves the value in member timestamp
 * @param _timestamp New value to be moved in member timestamp
 */
void BigData::timestamp(
        Timestamp&& _timestamp)
{
    m_timestamp = std::move(_timestamp);
}

/*!
 * @brief This function returns a constant reference to member timestamp
 * @return Constant reference to member timestamp
 */
const Timestamp& BigData::timestamp() const
{
    return m_timestamp;
}

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
Timestamp& BigData::timestamp()
{
    return m_timestamp;
}
/*!
 * @brief This function sets a value in member bool_value
 * @param _bool_value New value for member bool_value
 */
void BigData::bool_value(
        bool _bool_value)
{
    m_bool_value = _bool_value;
}

/*!
 * @brief This function returns the value of member bool_value
 * @return Value of member bool_value
 */
bool BigData::bool_value() const
{
    return m_bool_value;
}

/*!
 * @brief This function returns a reference to member bool_value
 * @return Reference to member bool_value
 */
bool& BigData::bool_value()
{
    return m_bool_value;
}

/*!
 * @brief This function sets a value in member int32_value
 * @param _int32_value New value for member int32_value
 */
void BigData::int32_value(
        int32_t _int32_value)
{
    m_int32_value = _int32_value;
}

/*!
 * @brief This function returns the value of member int32_value
 * @return Value of member int32_value
 */
int32_t BigData::int32_value() const
{
    return m_int32_value;
}

/*!
 * @brief This function returns a reference to member int32_value
 * @return Reference to member int32_value
 */
int32_t& BigData::int32_value()
{
    return m_int32_value;
}

/*!
 * @brief This function sets a value in member uint32_value
 * @param _uint32_value New value for member uint32_value
 */
void BigData::uint32_value(
        uint32_t _uint32_value)
{
    m_uint32_value = _uint32_value;
}

/*!
 * @brief This function returns the value of member uint32_value
 * @return Value of member uint32_value
 */
uint32_t BigData::uint32_value() const
{
    return m_uint32_value;
}

/*!
 * @brief This function returns a reference to member uint32_value
 * @return Reference to member uint32_value
 */
uint32_t& BigData::uint32_value()
{
    return m_uint32_value;
}

/*!
 * @brief This function sets a value in member int64_value
 * @param _int64_value New value for member int64_value
 */
void BigData::int64_value(
        int64_t _int64_value)
{
    m_int64_value = _int64_value;
}

/*!
 * @brief This function returns the value of member int64_value
 * @return Value of member int64_value
 */
int64_t BigData::int64_value() const
{
    return m_int64_value;
}

/*!
 * @brief This function returns a reference to member int64_value
 * @return Reference to member int64_value
 */
int64_t& BigData::int64_value()
{
    return m_int64_value;
}

/*!
 * @brief This function sets a value in member uint64_value
 * @param _uint64_value New value for member uint64_value
 */
void BigData::uint64_value(
        uint64_t _uint64_value)
{
    m_uint64_value = _uint64_value;
}

/*!
 * @brief This function returns the value of member uint64_value
 * @return Value of member uint64_value
 */
uint64_t BigData::uint64_value() const
{
    return m_uint64_value;
}

/*!
 * @brief This function returns a reference to member uint64_value
 * @return Reference to member uint64_value
 */
uint64_t& BigData::uint64_value()
{
    return m_uint64_value;
}

/*!
 * @brief This function sets a value in member float_value
 * @param _float_value New value for member float_value
 */
void BigData::float_value(
        float _float_value)
{
    m_float_value = _float_value;
}

/*!
 * @brief This function returns the value of member float_value
 * @return Value of member float_value
 */
float BigData::float_value() const
{
    return m_float_value;
}

/*!
 * @brief This function returns a reference to member float_value
 * @return Reference to member float_value
 */
float& BigData::float_value()
{
    return m_float_value;
}

/*!
 * @brief This function sets a value in member double_value
 * @param _double_value New value for member double_value
 */
void BigData::double_value(
        double _double_value)
{
    m_double_value = _double_value;
}

/*!
 * @brief This function returns the value of member double_value
 * @return Value of member double_value
 */
double BigData::double_value() const
{
    return m_double_value;
}

/*!
 * @brief This function returns a reference to member double_value
 * @return Reference to member double_value
 */
double& BigData::double_value()
{
    return m_double_value;
}

/*!
 * @brief This function copies the value in member string_value
 * @param _string_value New value to be copied in member string_value
 */
void BigData::string_value(
        const std::string& _string_value)
{
    m_string_value = _string_value;
}

/*!
 * @brief This function moves the value in member string_value
 * @param _string_value New value to be moved in member string_value
 */
void BigData::string_value(
        std::string&& _string_value)
{
    m_string_value = std::move(_string_value);
}

/*!
 * @brief This function returns a constant reference to member string_value
 * @return Constant reference to member string_value
 */
const std::string& BigData::string_value() const
{
    return m_string_value;
}

/*!
 * @brief This function returns a reference to member string_value
 * @return Reference to member string_value
 */
std::string& BigData::string_value()
{
    return m_string_value;
}
/*!
 * @brief This function copies the value in member basic_types_values
 * @param _basic_types_values New value to be copied in member basic_types_values
 */
void BigData::basic_types_values(
        const std::vector<BasicTypes>& _basic_types_values)
{
    m_basic_types_values = _basic_types_values;
}

/*!
 * @brief This function moves the value in member basic_types_values
 * @param _basic_types_values New value to be moved in member basic_types_values
 */
void BigData::basic_types_values(
        std::vector<BasicTypes>&& _basic_types_values)
{
    m_basic_types_values = std::move(_basic_types_values);
}

/*!
 * @brief This function returns a constant reference to member basic_types_values
 * @return Constant reference to member basic_types_values
 */
const std::vector<BasicTypes>& BigData::basic_types_values() const
{
    return m_basic_types_values;
}

/*!
 * @brief This function returns a reference to member basic_types_values
 * @return Reference to member basic_types_values
 */
std::vector<BasicTypes>& BigData::basic_types_values()
{
    return m_basic_types_values;
}
/*!
 * @brief This function copies the value in member image_value
 * @param _image_value New value to be copied in member image_value
 */
void BigData::image_value(
        const Image& _image_value)
{
    m_image_value = _image_value;
}

/*!
 * @brief This function moves the value in member image_value
 * @param _image_value New value to be moved in member image_value
 */
void BigData::image_value(
        Image&& _image_value)
{
    m_image_value = std::move(_image_value);
}

/*!
 * @brief This function returns a constant reference to member image_value
 * @return Constant reference to member image_value
 */
const Image& BigData::image_value() const
{
    return m_image_value;
}

/*!
 * @brief This function returns a reference to member image_value
 * @return Reference to member image_value
 */
Image& BigData::image_value()
{
    return m_image_value;
}
/*!
 * @brief This function copies the value in member point_cloud_value
 * @param _point_cloud_value New value to be copied in member point_cloud_value
 */
void BigData::point_cloud_value(
        const PointCloud2& _point_cloud_value)
{
    m_point_cloud_value = _point_cloud_value;
}

/*!
 * @brief This function moves the value in member point_cloud_value
 * @param _point_cloud_value New value to be moved in member point_cloud_value
 */
void BigData::point_cloud_value(
        PointCloud2&& _point_cloud_value)
{
    m_point_cloud_value = std::move(_point_cloud_value);
}

/*!
 * @brief This function returns a constant reference to member point_cloud_value
 * @return Constant reference to member point_cloud_value
 */
const PointCloud2& BigData::point_cloud_value() const
{
    return m_point_cloud_value;
}

/*!
 * @brief This function returns a reference to member point_cloud_value
 * @return Reference to member point_cloud_value
 */
PointCloud2& BigData::point_cloud_value()
{
    return m_point_cloud_value;
}

size_t BigData::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;















    return current_align;
}

bool BigData::isKeyDefined()
{
    return false;
}

void BigData::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
                
}
