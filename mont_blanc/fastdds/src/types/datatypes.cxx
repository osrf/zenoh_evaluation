// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file datatypes.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "types/datatypes.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

Int32::Int32()
{
    // m_data com.eprosima.idl.parser.typecode.PrimitiveTypeCode@cb0ed20
    m_data = 0;

}

Int32::~Int32()
{
}

Int32::Int32(
        const Int32& x)
{
    m_data = x.m_data;
}

Int32::Int32(
        Int32&& x)
{
    m_data = x.m_data;
}

Int32& Int32::operator =(
        const Int32& x)
{

    m_data = x.m_data;

    return *this;
}

Int32& Int32::operator =(
        Int32&& x)
{

    m_data = x.m_data;

    return *this;
}

bool Int32::operator ==(
        const Int32& x)
{

    return (m_data == x.m_data);
}

bool Int32::operator !=(
        const Int32& x)
{
    return !(*this == x);
}

size_t Int32::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t Int32::getCdrSerializedSize(
        const Int32& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void Int32::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_data;

}

void Int32::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_data;
}

/*!
 * @brief This function sets a value in member data
 * @param _data New value for member data
 */
void Int32::data(
        int32_t _data)
{
    m_data = _data;
}

/*!
 * @brief This function returns the value of member data
 * @return Value of member data
 */
int32_t Int32::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
int32_t& Int32::data()
{
    return m_data;
}


size_t Int32::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool Int32::isKeyDefined()
{
    return false;
}

void Int32::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

Int64::Int64()
{
    // m_data com.eprosima.idl.parser.typecode.PrimitiveTypeCode@43738a82
    m_data = 0;

}

Int64::~Int64()
{
}

Int64::Int64(
        const Int64& x)
{
    m_data = x.m_data;
}

Int64::Int64(
        Int64&& x)
{
    m_data = x.m_data;
}

Int64& Int64::operator =(
        const Int64& x)
{

    m_data = x.m_data;

    return *this;
}

Int64& Int64::operator =(
        Int64&& x)
{

    m_data = x.m_data;

    return *this;
}

bool Int64::operator ==(
        const Int64& x)
{

    return (m_data == x.m_data);
}

bool Int64::operator !=(
        const Int64& x)
{
    return !(*this == x);
}

size_t Int64::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t Int64::getCdrSerializedSize(
        const Int64& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void Int64::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_data;

}

void Int64::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_data;
}

/*!
 * @brief This function sets a value in member data
 * @param _data New value for member data
 */
void Int64::data(
        int64_t _data)
{
    m_data = _data;
}

/*!
 * @brief This function returns the value of member data
 * @return Value of member data
 */
int64_t Int64::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
int64_t& Int64::data()
{
    return m_data;
}


size_t Int64::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool Int64::isKeyDefined()
{
    return false;
}

void Int64::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

Float32::Float32()
{
    // m_data com.eprosima.idl.parser.typecode.PrimitiveTypeCode@22eeefeb
    m_data = 0.0;

}

Float32::~Float32()
{
}

Float32::Float32(
        const Float32& x)
{
    m_data = x.m_data;
}

Float32::Float32(
        Float32&& x)
{
    m_data = x.m_data;
}

Float32& Float32::operator =(
        const Float32& x)
{

    m_data = x.m_data;

    return *this;
}

Float32& Float32::operator =(
        Float32&& x)
{

    m_data = x.m_data;

    return *this;
}

bool Float32::operator ==(
        const Float32& x)
{

    return (m_data == x.m_data);
}

bool Float32::operator !=(
        const Float32& x)
{
    return !(*this == x);
}

size_t Float32::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t Float32::getCdrSerializedSize(
        const Float32& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void Float32::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_data;

}

void Float32::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_data;
}

/*!
 * @brief This function sets a value in member data
 * @param _data New value for member data
 */
void Float32::data(
        float _data)
{
    m_data = _data;
}

/*!
 * @brief This function returns the value of member data
 * @return Value of member data
 */
float Float32::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
float& Float32::data()
{
    return m_data;
}


size_t Float32::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool Float32::isKeyDefined()
{
    return false;
}

void Float32::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

Float64::Float64()
{
    // m_data com.eprosima.idl.parser.typecode.PrimitiveTypeCode@78ac1102
    m_data = 0.0;

}

Float64::~Float64()
{
}

Float64::Float64(
        const Float64& x)
{
    m_data = x.m_data;
}

Float64::Float64(
        Float64&& x)
{
    m_data = x.m_data;
}

Float64& Float64::operator =(
        const Float64& x)
{

    m_data = x.m_data;

    return *this;
}

Float64& Float64::operator =(
        Float64&& x)
{

    m_data = x.m_data;

    return *this;
}

bool Float64::operator ==(
        const Float64& x)
{

    return (m_data == x.m_data);
}

bool Float64::operator !=(
        const Float64& x)
{
    return !(*this == x);
}

size_t Float64::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t Float64::getCdrSerializedSize(
        const Float64& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void Float64::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_data;

}

void Float64::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_data;
}

/*!
 * @brief This function sets a value in member data
 * @param _data New value for member data
 */
void Float64::data(
        double _data)
{
    m_data = _data;
}

/*!
 * @brief This function returns the value of member data
 * @return Value of member data
 */
double Float64::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
double& Float64::data()
{
    return m_data;
}


size_t Float64::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool Float64::isKeyDefined()
{
    return false;
}

void Float64::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

String::String()
{
    // m_data com.eprosima.idl.parser.typecode.StringTypeCode@6ec8211c
    m_data ="";

}

String::~String()
{
}

String::String(
        const String& x)
{
    m_data = x.m_data;
}

String::String(
        String&& x)
{
    m_data = std::move(x.m_data);
}

String& String::operator =(
        const String& x)
{

    m_data = x.m_data;

    return *this;
}

String& String::operator =(
        String&& x)
{

    m_data = std::move(x.m_data);

    return *this;
}

bool String::operator ==(
        const String& x)
{

    return (m_data == x.m_data);
}

bool String::operator !=(
        const String& x)
{
    return !(*this == x);
}

size_t String::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t String::getCdrSerializedSize(
        const String& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.data().size() + 1;

    return current_alignment - initial_alignment;
}

void String::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_data;

}

void String::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_data;
}

/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void String::data(
        const std::string& _data)
{
    m_data = _data;
}

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void String::data(
        std::string&& _data)
{
    m_data = std::move(_data);
}

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::string& String::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::string& String::data()
{
    return m_data;
}

size_t String::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool String::isKeyDefined()
{
    return false;
}

void String::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

Timestamp::Timestamp()
{
    // m_sec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2eda0940
    m_sec = 0;
    // m_nanosec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@3578436e
    m_nanosec = 0;

}

Timestamp::~Timestamp()
{


}

Timestamp::Timestamp(
        const Timestamp& x)
{
    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
}

Timestamp::Timestamp(
        Timestamp&& x)
{
    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
}

Timestamp& Timestamp::operator =(
        const Timestamp& x)
{

    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;

    return *this;
}

Timestamp& Timestamp::operator =(
        Timestamp&& x)
{

    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;

    return *this;
}

bool Timestamp::operator ==(
        const Timestamp& x)
{

    return (m_sec == x.m_sec && m_nanosec == x.m_nanosec);
}

bool Timestamp::operator !=(
        const Timestamp& x)
{
    return !(*this == x);
}

size_t Timestamp::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t Timestamp::getCdrSerializedSize(
        const Timestamp& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void Timestamp::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_sec;
    scdr << m_nanosec;

}

void Timestamp::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_sec;
    dcdr >> m_nanosec;
}

/*!
 * @brief This function sets a value in member sec
 * @param _sec New value for member sec
 */
void Timestamp::sec(
        uint64_t _sec)
{
    m_sec = _sec;
}

/*!
 * @brief This function returns the value of member sec
 * @return Value of member sec
 */
uint64_t Timestamp::sec() const
{
    return m_sec;
}

/*!
 * @brief This function returns a reference to member sec
 * @return Reference to member sec
 */
uint64_t& Timestamp::sec()
{
    return m_sec;
}

/*!
 * @brief This function sets a value in member nanosec
 * @param _nanosec New value for member nanosec
 */
void Timestamp::nanosec(
        uint32_t _nanosec)
{
    m_nanosec = _nanosec;
}

/*!
 * @brief This function returns the value of member nanosec
 * @return Value of member nanosec
 */
uint32_t Timestamp::nanosec() const
{
    return m_nanosec;
}

/*!
 * @brief This function returns a reference to member nanosec
 * @return Reference to member nanosec
 */
uint32_t& Timestamp::nanosec()
{
    return m_nanosec;
}


size_t Timestamp::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool Timestamp::isKeyDefined()
{
    return false;
}

void Timestamp::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

Header::Header()
{
    // m_sec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@10a035a0
    m_sec = 0;
    // m_nanosec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@67b467e9
    m_nanosec = 0;
    // m_frame_id com.eprosima.idl.parser.typecode.StringTypeCode@47db50c5
    m_frame_id ="";

}

Header::~Header()
{



}

Header::Header(
        const Header& x)
{
    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
    m_frame_id = x.m_frame_id;
}

Header::Header(
        Header&& x)
{
    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
    m_frame_id = std::move(x.m_frame_id);
}

Header& Header::operator =(
        const Header& x)
{

    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
    m_frame_id = x.m_frame_id;

    return *this;
}

Header& Header::operator =(
        Header&& x)
{

    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
    m_frame_id = std::move(x.m_frame_id);

    return *this;
}

bool Header::operator ==(
        const Header& x)
{

    return (m_sec == x.m_sec && m_nanosec == x.m_nanosec && m_frame_id == x.m_frame_id);
}

bool Header::operator !=(
        const Header& x)
{
    return !(*this == x);
}

size_t Header::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t Header::getCdrSerializedSize(
        const Header& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.frame_id().size() + 1;


    return current_alignment - initial_alignment;
}

void Header::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_sec;
    scdr << m_nanosec;
    scdr << m_frame_id;

}

void Header::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_sec;
    dcdr >> m_nanosec;
    dcdr >> m_frame_id;
}

/*!
 * @brief This function sets a value in member sec
 * @param _sec New value for member sec
 */
void Header::sec(
        int32_t _sec)
{
    m_sec = _sec;
}

/*!
 * @brief This function returns the value of member sec
 * @return Value of member sec
 */
int32_t Header::sec() const
{
    return m_sec;
}

/*!
 * @brief This function returns a reference to member sec
 * @return Reference to member sec
 */
int32_t& Header::sec()
{
    return m_sec;
}

/*!
 * @brief This function sets a value in member nanosec
 * @param _nanosec New value for member nanosec
 */
void Header::nanosec(
        uint32_t _nanosec)
{
    m_nanosec = _nanosec;
}

/*!
 * @brief This function returns the value of member nanosec
 * @return Value of member nanosec
 */
uint32_t Header::nanosec() const
{
    return m_nanosec;
}

/*!
 * @brief This function returns a reference to member nanosec
 * @return Reference to member nanosec
 */
uint32_t& Header::nanosec()
{
    return m_nanosec;
}

/*!
 * @brief This function copies the value in member frame_id
 * @param _frame_id New value to be copied in member frame_id
 */
void Header::frame_id(
        const std::string& _frame_id)
{
    m_frame_id = _frame_id;
}

/*!
 * @brief This function moves the value in member frame_id
 * @param _frame_id New value to be moved in member frame_id
 */
void Header::frame_id(
        std::string&& _frame_id)
{
    m_frame_id = std::move(_frame_id);
}

/*!
 * @brief This function returns a constant reference to member frame_id
 * @return Constant reference to member frame_id
 */
const std::string& Header::frame_id() const
{
    return m_frame_id;
}

/*!
 * @brief This function returns a reference to member frame_id
 * @return Reference to member frame_id
 */
std::string& Header::frame_id()
{
    return m_frame_id;
}

size_t Header::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool Header::isKeyDefined()
{
    return false;
}

void Header::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

Point::Point()
{
    // m_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2641e737
    m_x = 0.0;
    // m_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@727803de
    m_y = 0.0;
    // m_z com.eprosima.idl.parser.typecode.PrimitiveTypeCode@704921a5
    m_z = 0.0;

}

Point::~Point()
{



}

Point::Point(
        const Point& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Point::Point(
        Point&& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Point& Point::operator =(
        const Point& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

Point& Point::operator =(
        Point&& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

bool Point::operator ==(
        const Point& x)
{

    return (m_x == x.m_x && m_y == x.m_y && m_z == x.m_z);
}

bool Point::operator !=(
        const Point& x)
{
    return !(*this == x);
}

size_t Point::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t Point::getCdrSerializedSize(
        const Point& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void Point::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x;
    scdr << m_y;
    scdr << m_z;

}

void Point::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x;
    dcdr >> m_y;
    dcdr >> m_z;
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void Point::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double Point::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& Point::x()
{
    return m_x;
}

/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void Point::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double Point::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& Point::y()
{
    return m_y;
}

/*!
 * @brief This function sets a value in member z
 * @param _z New value for member z
 */
void Point::z(
        double _z)
{
    m_z = _z;
}

/*!
 * @brief This function returns the value of member z
 * @return Value of member z
 */
double Point::z() const
{
    return m_z;
}

/*!
 * @brief This function returns a reference to member z
 * @return Reference to member z
 */
double& Point::z()
{
    return m_z;
}


size_t Point::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool Point::isKeyDefined()
{
    return false;
}

void Point::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

Quaternion::Quaternion()
{
    // m_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@319b92f3
    m_x = 0.0;
    // m_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@fcd6521
    m_y = 0.0;
    // m_z com.eprosima.idl.parser.typecode.PrimitiveTypeCode@31f924f5
    m_z = 0.0;
    // m_w com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4fcd19b3
    m_w = 0.0;

}

Quaternion::~Quaternion()
{




}

Quaternion::Quaternion(
        const Quaternion& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;
}

Quaternion::Quaternion(
        Quaternion&& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;
}

Quaternion& Quaternion::operator =(
        const Quaternion& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;

    return *this;
}

Quaternion& Quaternion::operator =(
        Quaternion&& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;

    return *this;
}

bool Quaternion::operator ==(
        const Quaternion& x)
{

    return (m_x == x.m_x && m_y == x.m_y && m_z == x.m_z && m_w == x.m_w);
}

bool Quaternion::operator !=(
        const Quaternion& x)
{
    return !(*this == x);
}

size_t Quaternion::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t Quaternion::getCdrSerializedSize(
        const Quaternion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void Quaternion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x;
    scdr << m_y;
    scdr << m_z;
    scdr << m_w;

}

void Quaternion::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x;
    dcdr >> m_y;
    dcdr >> m_z;
    dcdr >> m_w;
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void Quaternion::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double Quaternion::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& Quaternion::x()
{
    return m_x;
}

/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void Quaternion::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double Quaternion::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& Quaternion::y()
{
    return m_y;
}

/*!
 * @brief This function sets a value in member z
 * @param _z New value for member z
 */
void Quaternion::z(
        double _z)
{
    m_z = _z;
}

/*!
 * @brief This function returns the value of member z
 * @return Value of member z
 */
double Quaternion::z() const
{
    return m_z;
}

/*!
 * @brief This function returns a reference to member z
 * @return Reference to member z
 */
double& Quaternion::z()
{
    return m_z;
}

/*!
 * @brief This function sets a value in member w
 * @param _w New value for member w
 */
void Quaternion::w(
        double _w)
{
    m_w = _w;
}

/*!
 * @brief This function returns the value of member w
 * @return Value of member w
 */
double Quaternion::w() const
{
    return m_w;
}

/*!
 * @brief This function returns a reference to member w
 * @return Reference to member w
 */
double& Quaternion::w()
{
    return m_w;
}


size_t Quaternion::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool Quaternion::isKeyDefined()
{
    return false;
}

void Quaternion::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

Vector3::Vector3()
{
    // m_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@376b4233
    m_x = 0.0;
    // m_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7a36aefa
    m_y = 0.0;
    // m_z com.eprosima.idl.parser.typecode.PrimitiveTypeCode@17211155
    m_z = 0.0;

}

Vector3::~Vector3()
{



}

Vector3::Vector3(
        const Vector3& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Vector3::Vector3(
        Vector3&& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Vector3& Vector3::operator =(
        const Vector3& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

Vector3& Vector3::operator =(
        Vector3&& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

bool Vector3::operator ==(
        const Vector3& x)
{

    return (m_x == x.m_x && m_y == x.m_y && m_z == x.m_z);
}

bool Vector3::operator !=(
        const Vector3& x)
{
    return !(*this == x);
}

size_t Vector3::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t Vector3::getCdrSerializedSize(
        const Vector3& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void Vector3::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x;
    scdr << m_y;
    scdr << m_z;

}

void Vector3::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x;
    dcdr >> m_y;
    dcdr >> m_z;
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void Vector3::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double Vector3::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& Vector3::x()
{
    return m_x;
}

/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void Vector3::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double Vector3::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& Vector3::y()
{
    return m_y;
}

/*!
 * @brief This function sets a value in member z
 * @param _z New value for member z
 */
void Vector3::z(
        double _z)
{
    m_z = _z;
}

/*!
 * @brief This function returns the value of member z
 * @return Value of member z
 */
double Vector3::z() const
{
    return m_z;
}

/*!
 * @brief This function returns a reference to member z
 * @return Reference to member z
 */
double& Vector3::z()
{
    return m_z;
}


size_t Vector3::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool Vector3::isKeyDefined()
{
    return false;
}

void Vector3::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

Vector3Stamped::Vector3Stamped()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@641147d0

    // m_vector com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@6e38921c


}

Vector3Stamped::~Vector3Stamped()
{


}

Vector3Stamped::Vector3Stamped(
        const Vector3Stamped& x)
{
    m_header = x.m_header;
    m_vector = x.m_vector;
}

Vector3Stamped::Vector3Stamped(
        Vector3Stamped&& x)
{
    m_header = std::move(x.m_header);
    m_vector = std::move(x.m_vector);
}

Vector3Stamped& Vector3Stamped::operator =(
        const Vector3Stamped& x)
{

    m_header = x.m_header;
    m_vector = x.m_vector;

    return *this;
}

Vector3Stamped& Vector3Stamped::operator =(
        Vector3Stamped&& x)
{

    m_header = std::move(x.m_header);
    m_vector = std::move(x.m_vector);

    return *this;
}

bool Vector3Stamped::operator ==(
        const Vector3Stamped& x)
{

    return (m_header == x.m_header && m_vector == x.m_vector);
}

bool Vector3Stamped::operator !=(
        const Vector3Stamped& x)
{
    return !(*this == x);
}

size_t Vector3Stamped::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Vector3::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t Vector3Stamped::getCdrSerializedSize(
        const Vector3Stamped& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += Vector3::getCdrSerializedSize(data.vector(), current_alignment);

    return current_alignment - initial_alignment;
}

void Vector3Stamped::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_vector;

}

void Vector3Stamped::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_vector;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void Vector3Stamped::header(
        const Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void Vector3Stamped::header(
        Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const Header& Vector3Stamped::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
Header& Vector3Stamped::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member vector
 * @param _vector New value to be copied in member vector
 */
void Vector3Stamped::vector(
        const Vector3& _vector)
{
    m_vector = _vector;
}

/*!
 * @brief This function moves the value in member vector
 * @param _vector New value to be moved in member vector
 */
void Vector3Stamped::vector(
        Vector3&& _vector)
{
    m_vector = std::move(_vector);
}

/*!
 * @brief This function returns a constant reference to member vector
 * @return Constant reference to member vector
 */
const Vector3& Vector3Stamped::vector() const
{
    return m_vector;
}

/*!
 * @brief This function returns a reference to member vector
 * @return Reference to member vector
 */
Vector3& Vector3Stamped::vector()
{
    return m_vector;
}

size_t Vector3Stamped::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool Vector3Stamped::isKeyDefined()
{
    return false;
}

void Vector3Stamped::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

Pose::Pose()
{
    // m_position com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@38364841

    // m_orientation com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@28c4711c


}

Pose::~Pose()
{


}

Pose::Pose(
        const Pose& x)
{
    m_position = x.m_position;
    m_orientation = x.m_orientation;
}

Pose::Pose(
        Pose&& x)
{
    m_position = std::move(x.m_position);
    m_orientation = std::move(x.m_orientation);
}

Pose& Pose::operator =(
        const Pose& x)
{

    m_position = x.m_position;
    m_orientation = x.m_orientation;

    return *this;
}

Pose& Pose::operator =(
        Pose&& x)
{

    m_position = std::move(x.m_position);
    m_orientation = std::move(x.m_orientation);

    return *this;
}

bool Pose::operator ==(
        const Pose& x)
{

    return (m_position == x.m_position && m_orientation == x.m_orientation);
}

bool Pose::operator !=(
        const Pose& x)
{
    return !(*this == x);
}

size_t Pose::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Point::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Quaternion::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t Pose::getCdrSerializedSize(
        const Pose& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Point::getCdrSerializedSize(data.position(), current_alignment);
    current_alignment += Quaternion::getCdrSerializedSize(data.orientation(), current_alignment);

    return current_alignment - initial_alignment;
}

void Pose::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_position;
    scdr << m_orientation;

}

void Pose::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_position;
    dcdr >> m_orientation;
}

/*!
 * @brief This function copies the value in member position
 * @param _position New value to be copied in member position
 */
void Pose::position(
        const Point& _position)
{
    m_position = _position;
}

/*!
 * @brief This function moves the value in member position
 * @param _position New value to be moved in member position
 */
void Pose::position(
        Point&& _position)
{
    m_position = std::move(_position);
}

/*!
 * @brief This function returns a constant reference to member position
 * @return Constant reference to member position
 */
const Point& Pose::position() const
{
    return m_position;
}

/*!
 * @brief This function returns a reference to member position
 * @return Reference to member position
 */
Point& Pose::position()
{
    return m_position;
}
/*!
 * @brief This function copies the value in member orientation
 * @param _orientation New value to be copied in member orientation
 */
void Pose::orientation(
        const Quaternion& _orientation)
{
    m_orientation = _orientation;
}

/*!
 * @brief This function moves the value in member orientation
 * @param _orientation New value to be moved in member orientation
 */
void Pose::orientation(
        Quaternion&& _orientation)
{
    m_orientation = std::move(_orientation);
}

/*!
 * @brief This function returns a constant reference to member orientation
 * @return Constant reference to member orientation
 */
const Quaternion& Pose::orientation() const
{
    return m_orientation;
}

/*!
 * @brief This function returns a reference to member orientation
 * @return Reference to member orientation
 */
Quaternion& Pose::orientation()
{
    return m_orientation;
}

size_t Pose::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool Pose::isKeyDefined()
{
    return false;
}

void Pose::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

Twist::Twist()
{
    // m_linear com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@6e38921c

    // m_angular com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@6e38921c


}

Twist::~Twist()
{


}

Twist::Twist(
        const Twist& x)
{
    m_linear = x.m_linear;
    m_angular = x.m_angular;
}

Twist::Twist(
        Twist&& x)
{
    m_linear = std::move(x.m_linear);
    m_angular = std::move(x.m_angular);
}

Twist& Twist::operator =(
        const Twist& x)
{

    m_linear = x.m_linear;
    m_angular = x.m_angular;

    return *this;
}

Twist& Twist::operator =(
        Twist&& x)
{

    m_linear = std::move(x.m_linear);
    m_angular = std::move(x.m_angular);

    return *this;
}

bool Twist::operator ==(
        const Twist& x)
{

    return (m_linear == x.m_linear && m_angular == x.m_angular);
}

bool Twist::operator !=(
        const Twist& x)
{
    return !(*this == x);
}

size_t Twist::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Vector3::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Vector3::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t Twist::getCdrSerializedSize(
        const Twist& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Vector3::getCdrSerializedSize(data.linear(), current_alignment);
    current_alignment += Vector3::getCdrSerializedSize(data.angular(), current_alignment);

    return current_alignment - initial_alignment;
}

void Twist::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_linear;
    scdr << m_angular;

}

void Twist::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_linear;
    dcdr >> m_angular;
}

/*!
 * @brief This function copies the value in member linear
 * @param _linear New value to be copied in member linear
 */
void Twist::linear(
        const Vector3& _linear)
{
    m_linear = _linear;
}

/*!
 * @brief This function moves the value in member linear
 * @param _linear New value to be moved in member linear
 */
void Twist::linear(
        Vector3&& _linear)
{
    m_linear = std::move(_linear);
}

/*!
 * @brief This function returns a constant reference to member linear
 * @return Constant reference to member linear
 */
const Vector3& Twist::linear() const
{
    return m_linear;
}

/*!
 * @brief This function returns a reference to member linear
 * @return Reference to member linear
 */
Vector3& Twist::linear()
{
    return m_linear;
}
/*!
 * @brief This function copies the value in member angular
 * @param _angular New value to be copied in member angular
 */
void Twist::angular(
        const Vector3& _angular)
{
    m_angular = _angular;
}

/*!
 * @brief This function moves the value in member angular
 * @param _angular New value to be moved in member angular
 */
void Twist::angular(
        Vector3&& _angular)
{
    m_angular = std::move(_angular);
}

/*!
 * @brief This function returns a constant reference to member angular
 * @return Constant reference to member angular
 */
const Vector3& Twist::angular() const
{
    return m_angular;
}

/*!
 * @brief This function returns a reference to member angular
 * @return Reference to member angular
 */
Vector3& Twist::angular()
{
    return m_angular;
}

size_t Twist::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool Twist::isKeyDefined()
{
    return false;
}

void Twist::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

TwistWithCovariance::TwistWithCovariance()
{
    // m_twist com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@51b7e5df

    // m_covariance com.eprosima.idl.parser.typecode.SequenceTypeCode@18a70f16


}

TwistWithCovariance::~TwistWithCovariance()
{


}

TwistWithCovariance::TwistWithCovariance(
        const TwistWithCovariance& x)
{
    m_twist = x.m_twist;
    m_covariance = x.m_covariance;
}

TwistWithCovariance::TwistWithCovariance(
        TwistWithCovariance&& x)
{
    m_twist = std::move(x.m_twist);
    m_covariance = std::move(x.m_covariance);
}

TwistWithCovariance& TwistWithCovariance::operator =(
        const TwistWithCovariance& x)
{

    m_twist = x.m_twist;
    m_covariance = x.m_covariance;

    return *this;
}

TwistWithCovariance& TwistWithCovariance::operator =(
        TwistWithCovariance&& x)
{

    m_twist = std::move(x.m_twist);
    m_covariance = std::move(x.m_covariance);

    return *this;
}

bool TwistWithCovariance::operator ==(
        const TwistWithCovariance& x)
{

    return (m_twist == x.m_twist && m_covariance == x.m_covariance);
}

bool TwistWithCovariance::operator !=(
        const TwistWithCovariance& x)
{
    return !(*this == x);
}

size_t TwistWithCovariance::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Twist::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);




    return current_alignment - initial_alignment;
}

size_t TwistWithCovariance::getCdrSerializedSize(
        const TwistWithCovariance& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Twist::getCdrSerializedSize(data.twist(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.covariance().size() > 0)
    {
        current_alignment += (data.covariance().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }




    return current_alignment - initial_alignment;
}

void TwistWithCovariance::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_twist;
    scdr << m_covariance;

}

void TwistWithCovariance::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_twist;
    dcdr >> m_covariance;
}

/*!
 * @brief This function copies the value in member twist
 * @param _twist New value to be copied in member twist
 */
void TwistWithCovariance::twist(
        const Twist& _twist)
{
    m_twist = _twist;
}

/*!
 * @brief This function moves the value in member twist
 * @param _twist New value to be moved in member twist
 */
void TwistWithCovariance::twist(
        Twist&& _twist)
{
    m_twist = std::move(_twist);
}

/*!
 * @brief This function returns a constant reference to member twist
 * @return Constant reference to member twist
 */
const Twist& TwistWithCovariance::twist() const
{
    return m_twist;
}

/*!
 * @brief This function returns a reference to member twist
 * @return Reference to member twist
 */
Twist& TwistWithCovariance::twist()
{
    return m_twist;
}
/*!
 * @brief This function copies the value in member covariance
 * @param _covariance New value to be copied in member covariance
 */
void TwistWithCovariance::covariance(
        const std::vector<double>& _covariance)
{
    m_covariance = _covariance;
}

/*!
 * @brief This function moves the value in member covariance
 * @param _covariance New value to be moved in member covariance
 */
void TwistWithCovariance::covariance(
        std::vector<double>&& _covariance)
{
    m_covariance = std::move(_covariance);
}

/*!
 * @brief This function returns a constant reference to member covariance
 * @return Constant reference to member covariance
 */
const std::vector<double>& TwistWithCovariance::covariance() const
{
    return m_covariance;
}

/*!
 * @brief This function returns a reference to member covariance
 * @return Reference to member covariance
 */
std::vector<double>& TwistWithCovariance::covariance()
{
    return m_covariance;
}

size_t TwistWithCovariance::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool TwistWithCovariance::isKeyDefined()
{
    return false;
}

void TwistWithCovariance::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

TwistWithCovarianceStamped::TwistWithCovarianceStamped()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@641147d0

    // m_twist com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@4d826d77


}

TwistWithCovarianceStamped::~TwistWithCovarianceStamped()
{


}

TwistWithCovarianceStamped::TwistWithCovarianceStamped(
        const TwistWithCovarianceStamped& x)
{
    m_header = x.m_header;
    m_twist = x.m_twist;
}

TwistWithCovarianceStamped::TwistWithCovarianceStamped(
        TwistWithCovarianceStamped&& x)
{
    m_header = std::move(x.m_header);
    m_twist = std::move(x.m_twist);
}

TwistWithCovarianceStamped& TwistWithCovarianceStamped::operator =(
        const TwistWithCovarianceStamped& x)
{

    m_header = x.m_header;
    m_twist = x.m_twist;

    return *this;
}

TwistWithCovarianceStamped& TwistWithCovarianceStamped::operator =(
        TwistWithCovarianceStamped&& x)
{

    m_header = std::move(x.m_header);
    m_twist = std::move(x.m_twist);

    return *this;
}

bool TwistWithCovarianceStamped::operator ==(
        const TwistWithCovarianceStamped& x)
{

    return (m_header == x.m_header && m_twist == x.m_twist);
}

bool TwistWithCovarianceStamped::operator !=(
        const TwistWithCovarianceStamped& x)
{
    return !(*this == x);
}

size_t TwistWithCovarianceStamped::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += TwistWithCovariance::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t TwistWithCovarianceStamped::getCdrSerializedSize(
        const TwistWithCovarianceStamped& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += TwistWithCovariance::getCdrSerializedSize(data.twist(), current_alignment);

    return current_alignment - initial_alignment;
}

void TwistWithCovarianceStamped::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_twist;

}

void TwistWithCovarianceStamped::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_twist;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void TwistWithCovarianceStamped::header(
        const Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void TwistWithCovarianceStamped::header(
        Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const Header& TwistWithCovarianceStamped::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
Header& TwistWithCovarianceStamped::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member twist
 * @param _twist New value to be copied in member twist
 */
void TwistWithCovarianceStamped::twist(
        const TwistWithCovariance& _twist)
{
    m_twist = _twist;
}

/*!
 * @brief This function moves the value in member twist
 * @param _twist New value to be moved in member twist
 */
void TwistWithCovarianceStamped::twist(
        TwistWithCovariance&& _twist)
{
    m_twist = std::move(_twist);
}

/*!
 * @brief This function returns a constant reference to member twist
 * @return Constant reference to member twist
 */
const TwistWithCovariance& TwistWithCovarianceStamped::twist() const
{
    return m_twist;
}

/*!
 * @brief This function returns a reference to member twist
 * @return Reference to member twist
 */
TwistWithCovariance& TwistWithCovarianceStamped::twist()
{
    return m_twist;
}

size_t TwistWithCovarianceStamped::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool TwistWithCovarianceStamped::isKeyDefined()
{
    return false;
}

void TwistWithCovarianceStamped::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

Wrench::Wrench()
{
    // m_force com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@6e38921c

    // m_torque com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@6e38921c


}

Wrench::~Wrench()
{


}

Wrench::Wrench(
        const Wrench& x)
{
    m_force = x.m_force;
    m_torque = x.m_torque;
}

Wrench::Wrench(
        Wrench&& x)
{
    m_force = std::move(x.m_force);
    m_torque = std::move(x.m_torque);
}

Wrench& Wrench::operator =(
        const Wrench& x)
{

    m_force = x.m_force;
    m_torque = x.m_torque;

    return *this;
}

Wrench& Wrench::operator =(
        Wrench&& x)
{

    m_force = std::move(x.m_force);
    m_torque = std::move(x.m_torque);

    return *this;
}

bool Wrench::operator ==(
        const Wrench& x)
{

    return (m_force == x.m_force && m_torque == x.m_torque);
}

bool Wrench::operator !=(
        const Wrench& x)
{
    return !(*this == x);
}

size_t Wrench::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Vector3::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Vector3::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t Wrench::getCdrSerializedSize(
        const Wrench& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Vector3::getCdrSerializedSize(data.force(), current_alignment);
    current_alignment += Vector3::getCdrSerializedSize(data.torque(), current_alignment);

    return current_alignment - initial_alignment;
}

void Wrench::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_force;
    scdr << m_torque;

}

void Wrench::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_force;
    dcdr >> m_torque;
}

/*!
 * @brief This function copies the value in member force
 * @param _force New value to be copied in member force
 */
void Wrench::force(
        const Vector3& _force)
{
    m_force = _force;
}

/*!
 * @brief This function moves the value in member force
 * @param _force New value to be moved in member force
 */
void Wrench::force(
        Vector3&& _force)
{
    m_force = std::move(_force);
}

/*!
 * @brief This function returns a constant reference to member force
 * @return Constant reference to member force
 */
const Vector3& Wrench::force() const
{
    return m_force;
}

/*!
 * @brief This function returns a reference to member force
 * @return Reference to member force
 */
Vector3& Wrench::force()
{
    return m_force;
}
/*!
 * @brief This function copies the value in member torque
 * @param _torque New value to be copied in member torque
 */
void Wrench::torque(
        const Vector3& _torque)
{
    m_torque = _torque;
}

/*!
 * @brief This function moves the value in member torque
 * @param _torque New value to be moved in member torque
 */
void Wrench::torque(
        Vector3&& _torque)
{
    m_torque = std::move(_torque);
}

/*!
 * @brief This function returns a constant reference to member torque
 * @return Constant reference to member torque
 */
const Vector3& Wrench::torque() const
{
    return m_torque;
}

/*!
 * @brief This function returns a reference to member torque
 * @return Reference to member torque
 */
Vector3& Wrench::torque()
{
    return m_torque;
}

size_t Wrench::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool Wrench::isKeyDefined()
{
    return false;
}

void Wrench::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

WrenchStamped::WrenchStamped()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@641147d0

    // m_wrench com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@15bb6bea


}

WrenchStamped::~WrenchStamped()
{


}

WrenchStamped::WrenchStamped(
        const WrenchStamped& x)
{
    m_header = x.m_header;
    m_wrench = x.m_wrench;
}

WrenchStamped::WrenchStamped(
        WrenchStamped&& x)
{
    m_header = std::move(x.m_header);
    m_wrench = std::move(x.m_wrench);
}

WrenchStamped& WrenchStamped::operator =(
        const WrenchStamped& x)
{

    m_header = x.m_header;
    m_wrench = x.m_wrench;

    return *this;
}

WrenchStamped& WrenchStamped::operator =(
        WrenchStamped&& x)
{

    m_header = std::move(x.m_header);
    m_wrench = std::move(x.m_wrench);

    return *this;
}

bool WrenchStamped::operator ==(
        const WrenchStamped& x)
{

    return (m_header == x.m_header && m_wrench == x.m_wrench);
}

bool WrenchStamped::operator !=(
        const WrenchStamped& x)
{
    return !(*this == x);
}

size_t WrenchStamped::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Wrench::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t WrenchStamped::getCdrSerializedSize(
        const WrenchStamped& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += Wrench::getCdrSerializedSize(data.wrench(), current_alignment);

    return current_alignment - initial_alignment;
}

void WrenchStamped::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_wrench;

}

void WrenchStamped::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_wrench;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void WrenchStamped::header(
        const Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void WrenchStamped::header(
        Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const Header& WrenchStamped::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
Header& WrenchStamped::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member wrench
 * @param _wrench New value to be copied in member wrench
 */
void WrenchStamped::wrench(
        const Wrench& _wrench)
{
    m_wrench = _wrench;
}

/*!
 * @brief This function moves the value in member wrench
 * @param _wrench New value to be moved in member wrench
 */
void WrenchStamped::wrench(
        Wrench&& _wrench)
{
    m_wrench = std::move(_wrench);
}

/*!
 * @brief This function returns a constant reference to member wrench
 * @return Constant reference to member wrench
 */
const Wrench& WrenchStamped::wrench() const
{
    return m_wrench;
}

/*!
 * @brief This function returns a reference to member wrench
 * @return Reference to member wrench
 */
Wrench& WrenchStamped::wrench()
{
    return m_wrench;
}

size_t WrenchStamped::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool WrenchStamped::isKeyDefined()
{
    return false;
}

void WrenchStamped::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

Image::Image()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@641147d0

    // m_height com.eprosima.idl.parser.typecode.PrimitiveTypeCode@41ee392b
    m_height = 0;
    // m_width com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1e67a849
    m_width = 0;
    // m_encoding com.eprosima.idl.parser.typecode.StringTypeCode@57d5872c
    m_encoding ="";
    // m_is_bigendian com.eprosima.idl.parser.typecode.PrimitiveTypeCode@667a738
    m_is_bigendian = false;
    // m_step com.eprosima.idl.parser.typecode.PrimitiveTypeCode@36f0f1be
    m_step = 0;
    // m_data com.eprosima.idl.parser.typecode.SequenceTypeCode@157632c9


}

Image::~Image()
{







}

Image::Image(
        const Image& x)
{
    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = x.m_encoding;
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = x.m_data;
}

Image::Image(
        Image&& x)
{
    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = std::move(x.m_encoding);
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = std::move(x.m_data);
}

Image& Image::operator =(
        const Image& x)
{

    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = x.m_encoding;
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = x.m_data;

    return *this;
}

Image& Image::operator =(
        Image&& x)
{

    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = std::move(x.m_encoding);
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = std::move(x.m_data);

    return *this;
}

bool Image::operator ==(
        const Image& x)
{

    return (m_header == x.m_header && m_height == x.m_height && m_width == x.m_width && m_encoding == x.m_encoding && m_is_bigendian == x.m_is_bigendian && m_step == x.m_step && m_data == x.m_data);
}

bool Image::operator !=(
        const Image& x)
{
    return !(*this == x);
}

size_t Image::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t Image::getCdrSerializedSize(
        const Image& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.encoding().size() + 1;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.data().size() > 0)
    {
        current_alignment += (data.data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }




    return current_alignment - initial_alignment;
}

void Image::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_height;
    scdr << m_width;
    scdr << m_encoding;
    scdr << m_is_bigendian;
    scdr << m_step;
    scdr << m_data;

}

void Image::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_height;
    dcdr >> m_width;
    dcdr >> m_encoding;
    dcdr >> m_is_bigendian;
    dcdr >> m_step;
    dcdr >> m_data;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void Image::header(
        const Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void Image::header(
        Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const Header& Image::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
Header& Image::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void Image::height(
        uint32_t _height)
{
    m_height = _height;
}

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
uint32_t Image::height() const
{
    return m_height;
}

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
uint32_t& Image::height()
{
    return m_height;
}

/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void Image::width(
        uint32_t _width)
{
    m_width = _width;
}

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
uint32_t Image::width() const
{
    return m_width;
}

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
uint32_t& Image::width()
{
    return m_width;
}

/*!
 * @brief This function copies the value in member encoding
 * @param _encoding New value to be copied in member encoding
 */
void Image::encoding(
        const std::string& _encoding)
{
    m_encoding = _encoding;
}

/*!
 * @brief This function moves the value in member encoding
 * @param _encoding New value to be moved in member encoding
 */
void Image::encoding(
        std::string&& _encoding)
{
    m_encoding = std::move(_encoding);
}

/*!
 * @brief This function returns a constant reference to member encoding
 * @return Constant reference to member encoding
 */
const std::string& Image::encoding() const
{
    return m_encoding;
}

/*!
 * @brief This function returns a reference to member encoding
 * @return Reference to member encoding
 */
std::string& Image::encoding()
{
    return m_encoding;
}
/*!
 * @brief This function sets a value in member is_bigendian
 * @param _is_bigendian New value for member is_bigendian
 */
void Image::is_bigendian(
        bool _is_bigendian)
{
    m_is_bigendian = _is_bigendian;
}

/*!
 * @brief This function returns the value of member is_bigendian
 * @return Value of member is_bigendian
 */
bool Image::is_bigendian() const
{
    return m_is_bigendian;
}

/*!
 * @brief This function returns a reference to member is_bigendian
 * @return Reference to member is_bigendian
 */
bool& Image::is_bigendian()
{
    return m_is_bigendian;
}

/*!
 * @brief This function sets a value in member step
 * @param _step New value for member step
 */
void Image::step(
        uint32_t _step)
{
    m_step = _step;
}

/*!
 * @brief This function returns the value of member step
 * @return Value of member step
 */
uint32_t Image::step() const
{
    return m_step;
}

/*!
 * @brief This function returns a reference to member step
 * @return Reference to member step
 */
uint32_t& Image::step()
{
    return m_step;
}

/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void Image::data(
        const std::vector<uint8_t>& _data)
{
    m_data = _data;
}

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void Image::data(
        std::vector<uint8_t>&& _data)
{
    m_data = std::move(_data);
}

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::vector<uint8_t>& Image::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::vector<uint8_t>& Image::data()
{
    return m_data;
}

size_t Image::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;










    return current_align;
}

bool Image::isKeyDefined()
{
    return false;
}

void Image::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}









PointField::PointField()
{
    // m_name com.eprosima.idl.parser.typecode.StringTypeCode@20d3d15a
    m_name ="";
    // m_offset com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2893de87
    m_offset = 0;
    // m_datatype com.eprosima.idl.parser.typecode.PrimitiveTypeCode@55ca8de8
    m_datatype = 0;
    // m_count com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2c34f934
    m_count = 0;

}

PointField::~PointField()
{




}

PointField::PointField(
        const PointField& x)
{
    m_name = x.m_name;
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;
}

PointField::PointField(
        PointField&& x)
{
    m_name = std::move(x.m_name);
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;
}

PointField& PointField::operator =(
        const PointField& x)
{

    m_name = x.m_name;
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;

    return *this;
}

PointField& PointField::operator =(
        PointField&& x)
{

    m_name = std::move(x.m_name);
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;

    return *this;
}

bool PointField::operator ==(
        const PointField& x)
{

    return (m_name == x.m_name && m_offset == x.m_offset && m_datatype == x.m_datatype && m_count == x.m_count);
}

// Manual patch
const bool PointField::operator ==(
        const PointField& x) const
{

    return (m_name == x.m_name && m_offset == x.m_offset && m_datatype == x.m_datatype && m_count == x.m_count);
}

bool PointField::operator !=(
        const PointField& x)
{
    return !(*this == x);
}

size_t PointField::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t PointField::getCdrSerializedSize(
        const PointField& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void PointField::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_name;
    scdr << m_offset;
    scdr << m_datatype;
    scdr << m_count;

}

void PointField::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_name;
    dcdr >> m_offset;
    dcdr >> m_datatype;
    dcdr >> m_count;
}

/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
void PointField::name(
        const std::string& _name)
{
    m_name = _name;
}

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
void PointField::name(
        std::string&& _name)
{
    m_name = std::move(_name);
}

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
const std::string& PointField::name() const
{
    return m_name;
}

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
std::string& PointField::name()
{
    return m_name;
}
/*!
 * @brief This function sets a value in member offset
 * @param _offset New value for member offset
 */
void PointField::offset(
        uint32_t _offset)
{
    m_offset = _offset;
}

/*!
 * @brief This function returns the value of member offset
 * @return Value of member offset
 */
uint32_t PointField::offset() const
{
    return m_offset;
}

/*!
 * @brief This function returns a reference to member offset
 * @return Reference to member offset
 */
uint32_t& PointField::offset()
{
    return m_offset;
}

/*!
 * @brief This function sets a value in member datatype
 * @param _datatype New value for member datatype
 */
void PointField::datatype(
        uint8_t _datatype)
{
    m_datatype = _datatype;
}

/*!
 * @brief This function returns the value of member datatype
 * @return Value of member datatype
 */
uint8_t PointField::datatype() const
{
    return m_datatype;
}

/*!
 * @brief This function returns a reference to member datatype
 * @return Reference to member datatype
 */
uint8_t& PointField::datatype()
{
    return m_datatype;
}

/*!
 * @brief This function sets a value in member count
 * @param _count New value for member count
 */
void PointField::count(
        uint32_t _count)
{
    m_count = _count;
}

/*!
 * @brief This function returns the value of member count
 * @return Value of member count
 */
uint32_t PointField::count() const
{
    return m_count;
}

/*!
 * @brief This function returns a reference to member count
 * @return Reference to member count
 */
uint32_t& PointField::count()
{
    return m_count;
}


size_t PointField::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool PointField::isKeyDefined()
{
    return false;
}

void PointField::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

PointCloud2::PointCloud2()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@641147d0

    // m_height com.eprosima.idl.parser.typecode.PrimitiveTypeCode@12d3a4e9
    m_height = 0;
    // m_width com.eprosima.idl.parser.typecode.PrimitiveTypeCode@240237d2
    m_width = 0;
    // m_fields com.eprosima.idl.parser.typecode.SequenceTypeCode@25a65b77

    // m_is_bigendian com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2ed0fbae
    m_is_bigendian = false;
    // m_point_step com.eprosima.idl.parser.typecode.PrimitiveTypeCode@212bf671
    m_point_step = 0;
    // m_row_step com.eprosima.idl.parser.typecode.PrimitiveTypeCode@14a2f921
    m_row_step = 0;
    // m_data com.eprosima.idl.parser.typecode.SequenceTypeCode@3c87521

    // m_is_dense com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2aece37d
    m_is_dense = false;

}

PointCloud2::~PointCloud2()
{









}

PointCloud2::PointCloud2(
        const PointCloud2& x)
{
    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = x.m_fields;
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = x.m_data;
    m_is_dense = x.m_is_dense;
}

PointCloud2::PointCloud2(
        PointCloud2&& x)
{
    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = std::move(x.m_fields);
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = std::move(x.m_data);
    m_is_dense = x.m_is_dense;
}

PointCloud2& PointCloud2::operator =(
        const PointCloud2& x)
{

    m_header = x.m_header;
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = x.m_fields;
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = x.m_data;
    m_is_dense = x.m_is_dense;

    return *this;
}

PointCloud2& PointCloud2::operator =(
        PointCloud2&& x)
{

    m_header = std::move(x.m_header);
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = std::move(x.m_fields);
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = std::move(x.m_data);
    m_is_dense = x.m_is_dense;

    return *this;
}

bool PointCloud2::operator ==(
        const PointCloud2& x)
{

    return (m_header == x.m_header && m_height == x.m_height && m_width == x.m_width && m_fields == x.m_fields && m_is_bigendian == x.m_is_bigendian && m_point_step == x.m_point_step && m_row_step == x.m_row_step && m_data == x.m_data && m_is_dense == x.m_is_dense);
}

bool PointCloud2::operator !=(
        const PointCloud2& x)
{
    return !(*this == x);
}

size_t PointCloud2::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += PointField::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t PointCloud2::getCdrSerializedSize(
        const PointCloud2& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.fields().size(); ++a)
    {
        current_alignment += PointField::getCdrSerializedSize(data.fields().at(a), current_alignment);}

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.data().size() > 0)
    {
        current_alignment += (data.data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }



    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void PointCloud2::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_height;
    scdr << m_width;
    scdr << m_fields;
    scdr << m_is_bigendian;
    scdr << m_point_step;
    scdr << m_row_step;
    scdr << m_data;
    scdr << m_is_dense;

}

void PointCloud2::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_height;
    dcdr >> m_width;
    dcdr >> m_fields;
    dcdr >> m_is_bigendian;
    dcdr >> m_point_step;
    dcdr >> m_row_step;
    dcdr >> m_data;
    dcdr >> m_is_dense;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void PointCloud2::header(
        const Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void PointCloud2::header(
        Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const Header& PointCloud2::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
Header& PointCloud2::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void PointCloud2::height(
        uint32_t _height)
{
    m_height = _height;
}

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
uint32_t PointCloud2::height() const
{
    return m_height;
}

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
uint32_t& PointCloud2::height()
{
    return m_height;
}

/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void PointCloud2::width(
        uint32_t _width)
{
    m_width = _width;
}

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
uint32_t PointCloud2::width() const
{
    return m_width;
}

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
uint32_t& PointCloud2::width()
{
    return m_width;
}

/*!
 * @brief This function copies the value in member fields
 * @param _fields New value to be copied in member fields
 */
void PointCloud2::fields(
        const std::vector<PointField>& _fields)
{
    m_fields = _fields;
}

/*!
 * @brief This function moves the value in member fields
 * @param _fields New value to be moved in member fields
 */
void PointCloud2::fields(
        std::vector<PointField>&& _fields)
{
    m_fields = std::move(_fields);
}

/*!
 * @brief This function returns a constant reference to member fields
 * @return Constant reference to member fields
 */
const std::vector<PointField>& PointCloud2::fields() const
{
    return m_fields;
}

/*!
 * @brief This function returns a reference to member fields
 * @return Reference to member fields
 */
std::vector<PointField>& PointCloud2::fields()
{
    return m_fields;
}
/*!
 * @brief This function sets a value in member is_bigendian
 * @param _is_bigendian New value for member is_bigendian
 */
void PointCloud2::is_bigendian(
        bool _is_bigendian)
{
    m_is_bigendian = _is_bigendian;
}

/*!
 * @brief This function returns the value of member is_bigendian
 * @return Value of member is_bigendian
 */
bool PointCloud2::is_bigendian() const
{
    return m_is_bigendian;
}

/*!
 * @brief This function returns a reference to member is_bigendian
 * @return Reference to member is_bigendian
 */
bool& PointCloud2::is_bigendian()
{
    return m_is_bigendian;
}

/*!
 * @brief This function sets a value in member point_step
 * @param _point_step New value for member point_step
 */
void PointCloud2::point_step(
        uint32_t _point_step)
{
    m_point_step = _point_step;
}

/*!
 * @brief This function returns the value of member point_step
 * @return Value of member point_step
 */
uint32_t PointCloud2::point_step() const
{
    return m_point_step;
}

/*!
 * @brief This function returns a reference to member point_step
 * @return Reference to member point_step
 */
uint32_t& PointCloud2::point_step()
{
    return m_point_step;
}

/*!
 * @brief This function sets a value in member row_step
 * @param _row_step New value for member row_step
 */
void PointCloud2::row_step(
        uint32_t _row_step)
{
    m_row_step = _row_step;
}

/*!
 * @brief This function returns the value of member row_step
 * @return Value of member row_step
 */
uint32_t PointCloud2::row_step() const
{
    return m_row_step;
}

/*!
 * @brief This function returns a reference to member row_step
 * @return Reference to member row_step
 */
uint32_t& PointCloud2::row_step()
{
    return m_row_step;
}

/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void PointCloud2::data(
        const std::vector<uint8_t>& _data)
{
    m_data = _data;
}

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void PointCloud2::data(
        std::vector<uint8_t>&& _data)
{
    m_data = std::move(_data);
}

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::vector<uint8_t>& PointCloud2::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::vector<uint8_t>& PointCloud2::data()
{
    return m_data;
}
/*!
 * @brief This function sets a value in member is_dense
 * @param _is_dense New value for member is_dense
 */
void PointCloud2::is_dense(
        bool _is_dense)
{
    m_is_dense = _is_dense;
}

/*!
 * @brief This function returns the value of member is_dense
 * @return Value of member is_dense
 */
bool PointCloud2::is_dense() const
{
    return m_is_dense;
}

/*!
 * @brief This function returns a reference to member is_dense
 * @return Reference to member is_dense
 */
bool& PointCloud2::is_dense()
{
    return m_is_dense;
}


size_t PointCloud2::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;












    return current_align;
}

bool PointCloud2::isKeyDefined()
{
    return false;
}

void PointCloud2::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}

LaserScan::LaserScan()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@641147d0

    // m_angle_min com.eprosima.idl.parser.typecode.PrimitiveTypeCode@17c386de
    m_angle_min = 0.0;
    // m_angle_max com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5af97850
    m_angle_max = 0.0;
    // m_angle_increment com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5ef60048
    m_angle_increment = 0.0;
    // m_time_increment com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1d548a08
    m_time_increment = 0.0;
    // m_scan_time com.eprosima.idl.parser.typecode.PrimitiveTypeCode@16aa0a0a
    m_scan_time = 0.0;
    // m_range_min com.eprosima.idl.parser.typecode.PrimitiveTypeCode@780cb77
    m_range_min = 0.0;
    // m_range_max com.eprosima.idl.parser.typecode.PrimitiveTypeCode@691a7f8f
    m_range_max = 0.0;
    // m_ranges com.eprosima.idl.parser.typecode.SequenceTypeCode@50a7bc6e

    // m_intensities0 com.eprosima.idl.parser.typecode.SequenceTypeCode@161b062a


}

LaserScan::~LaserScan()
{










}

LaserScan::LaserScan(
        const LaserScan& x)
{
    m_header = x.m_header;
    m_angle_min = x.m_angle_min;
    m_angle_max = x.m_angle_max;
    m_angle_increment = x.m_angle_increment;
    m_time_increment = x.m_time_increment;
    m_scan_time = x.m_scan_time;
    m_range_min = x.m_range_min;
    m_range_max = x.m_range_max;
    m_ranges = x.m_ranges;
    m_intensities0 = x.m_intensities0;
}

LaserScan::LaserScan(
        LaserScan&& x)
{
    m_header = std::move(x.m_header);
    m_angle_min = x.m_angle_min;
    m_angle_max = x.m_angle_max;
    m_angle_increment = x.m_angle_increment;
    m_time_increment = x.m_time_increment;
    m_scan_time = x.m_scan_time;
    m_range_min = x.m_range_min;
    m_range_max = x.m_range_max;
    m_ranges = std::move(x.m_ranges);
    m_intensities0 = std::move(x.m_intensities0);
}

LaserScan& LaserScan::operator =(
        const LaserScan& x)
{

    m_header = x.m_header;
    m_angle_min = x.m_angle_min;
    m_angle_max = x.m_angle_max;
    m_angle_increment = x.m_angle_increment;
    m_time_increment = x.m_time_increment;
    m_scan_time = x.m_scan_time;
    m_range_min = x.m_range_min;
    m_range_max = x.m_range_max;
    m_ranges = x.m_ranges;
    m_intensities0 = x.m_intensities0;

    return *this;
}

LaserScan& LaserScan::operator =(
        LaserScan&& x)
{

    m_header = std::move(x.m_header);
    m_angle_min = x.m_angle_min;
    m_angle_max = x.m_angle_max;
    m_angle_increment = x.m_angle_increment;
    m_time_increment = x.m_time_increment;
    m_scan_time = x.m_scan_time;
    m_range_min = x.m_range_min;
    m_range_max = x.m_range_max;
    m_ranges = std::move(x.m_ranges);
    m_intensities0 = std::move(x.m_intensities0);

    return *this;
}

bool LaserScan::operator ==(
        const LaserScan& x)
{

    return (m_header == x.m_header && m_angle_min == x.m_angle_min && m_angle_max == x.m_angle_max && m_angle_increment == x.m_angle_increment && m_time_increment == x.m_time_increment && m_scan_time == x.m_scan_time && m_range_min == x.m_range_min && m_range_max == x.m_range_max && m_ranges == x.m_ranges && m_intensities0 == x.m_intensities0);
}

bool LaserScan::operator !=(
        const LaserScan& x)
{
    return !(*this == x);
}

size_t LaserScan::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);




    return current_alignment - initial_alignment;
}

size_t LaserScan::getCdrSerializedSize(
        const LaserScan& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.ranges().size() > 0)
    {
        current_alignment += (data.ranges().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.intensities0().size() > 0)
    {
        current_alignment += (data.intensities0().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }




    return current_alignment - initial_alignment;
}

void LaserScan::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_angle_min;
    scdr << m_angle_max;
    scdr << m_angle_increment;
    scdr << m_time_increment;
    scdr << m_scan_time;
    scdr << m_range_min;
    scdr << m_range_max;
    scdr << m_ranges;
    scdr << m_intensities0;

}

void LaserScan::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_angle_min;
    dcdr >> m_angle_max;
    dcdr >> m_angle_increment;
    dcdr >> m_time_increment;
    dcdr >> m_scan_time;
    dcdr >> m_range_min;
    dcdr >> m_range_max;
    dcdr >> m_ranges;
    dcdr >> m_intensities0;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void LaserScan::header(
        const Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void LaserScan::header(
        Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const Header& LaserScan::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
Header& LaserScan::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member angle_min
 * @param _angle_min New value for member angle_min
 */
void LaserScan::angle_min(
        float _angle_min)
{
    m_angle_min = _angle_min;
}

/*!
 * @brief This function returns the value of member angle_min
 * @return Value of member angle_min
 */
float LaserScan::angle_min() const
{
    return m_angle_min;
}

/*!
 * @brief This function returns a reference to member angle_min
 * @return Reference to member angle_min
 */
float& LaserScan::angle_min()
{
    return m_angle_min;
}

/*!
 * @brief This function sets a value in member angle_max
 * @param _angle_max New value for member angle_max
 */
void LaserScan::angle_max(
        float _angle_max)
{
    m_angle_max = _angle_max;
}

/*!
 * @brief This function returns the value of member angle_max
 * @return Value of member angle_max
 */
float LaserScan::angle_max() const
{
    return m_angle_max;
}

/*!
 * @brief This function returns a reference to member angle_max
 * @return Reference to member angle_max
 */
float& LaserScan::angle_max()
{
    return m_angle_max;
}

/*!
 * @brief This function sets a value in member angle_increment
 * @param _angle_increment New value for member angle_increment
 */
void LaserScan::angle_increment(
        float _angle_increment)
{
    m_angle_increment = _angle_increment;
}

/*!
 * @brief This function returns the value of member angle_increment
 * @return Value of member angle_increment
 */
float LaserScan::angle_increment() const
{
    return m_angle_increment;
}

/*!
 * @brief This function returns a reference to member angle_increment
 * @return Reference to member angle_increment
 */
float& LaserScan::angle_increment()
{
    return m_angle_increment;
}

/*!
 * @brief This function sets a value in member time_increment
 * @param _time_increment New value for member time_increment
 */
void LaserScan::time_increment(
        float _time_increment)
{
    m_time_increment = _time_increment;
}

/*!
 * @brief This function returns the value of member time_increment
 * @return Value of member time_increment
 */
float LaserScan::time_increment() const
{
    return m_time_increment;
}

/*!
 * @brief This function returns a reference to member time_increment
 * @return Reference to member time_increment
 */
float& LaserScan::time_increment()
{
    return m_time_increment;
}

/*!
 * @brief This function sets a value in member scan_time
 * @param _scan_time New value for member scan_time
 */
void LaserScan::scan_time(
        float _scan_time)
{
    m_scan_time = _scan_time;
}

/*!
 * @brief This function returns the value of member scan_time
 * @return Value of member scan_time
 */
float LaserScan::scan_time() const
{
    return m_scan_time;
}

/*!
 * @brief This function returns a reference to member scan_time
 * @return Reference to member scan_time
 */
float& LaserScan::scan_time()
{
    return m_scan_time;
}

/*!
 * @brief This function sets a value in member range_min
 * @param _range_min New value for member range_min
 */
void LaserScan::range_min(
        float _range_min)
{
    m_range_min = _range_min;
}

/*!
 * @brief This function returns the value of member range_min
 * @return Value of member range_min
 */
float LaserScan::range_min() const
{
    return m_range_min;
}

/*!
 * @brief This function returns a reference to member range_min
 * @return Reference to member range_min
 */
float& LaserScan::range_min()
{
    return m_range_min;
}

/*!
 * @brief This function sets a value in member range_max
 * @param _range_max New value for member range_max
 */
void LaserScan::range_max(
        float _range_max)
{
    m_range_max = _range_max;
}

/*!
 * @brief This function returns the value of member range_max
 * @return Value of member range_max
 */
float LaserScan::range_max() const
{
    return m_range_max;
}

/*!
 * @brief This function returns a reference to member range_max
 * @return Reference to member range_max
 */
float& LaserScan::range_max()
{
    return m_range_max;
}

/*!
 * @brief This function copies the value in member ranges
 * @param _ranges New value to be copied in member ranges
 */
void LaserScan::ranges(
        const std::vector<float>& _ranges)
{
    m_ranges = _ranges;
}

/*!
 * @brief This function moves the value in member ranges
 * @param _ranges New value to be moved in member ranges
 */
void LaserScan::ranges(
        std::vector<float>&& _ranges)
{
    m_ranges = std::move(_ranges);
}

/*!
 * @brief This function returns a constant reference to member ranges
 * @return Constant reference to member ranges
 */
const std::vector<float>& LaserScan::ranges() const
{
    return m_ranges;
}

/*!
 * @brief This function returns a reference to member ranges
 * @return Reference to member ranges
 */
std::vector<float>& LaserScan::ranges()
{
    return m_ranges;
}
/*!
 * @brief This function copies the value in member intensities0
 * @param _intensities0 New value to be copied in member intensities0
 */
void LaserScan::intensities0(
        const std::vector<float>& _intensities0)
{
    m_intensities0 = _intensities0;
}

/*!
 * @brief This function moves the value in member intensities0
 * @param _intensities0 New value to be moved in member intensities0
 */
void LaserScan::intensities0(
        std::vector<float>&& _intensities0)
{
    m_intensities0 = std::move(_intensities0);
}

/*!
 * @brief This function returns a constant reference to member intensities0
 * @return Constant reference to member intensities0
 */
const std::vector<float>& LaserScan::intensities0() const
{
    return m_intensities0;
}

/*!
 * @brief This function returns a reference to member intensities0
 * @return Reference to member intensities0
 */
std::vector<float>& LaserScan::intensities0()
{
    return m_intensities0;
}

size_t LaserScan::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;













    return current_align;
}

bool LaserScan::isKeyDefined()
{
    return false;
}

void LaserScan::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;

}
